\documentclass[a4paper,10pt]{scrartcl}
\usepackage{amsmath,amssymb,graphicx}
\usepackage{fullpage}
\parindent=0pt
\begin{document}
\title{QI Package for \emph{Mathematica} 7.0 \\(version 0.4.0)}\author{Jaros{\l}aw Adam Miszczak \quad Piotr Gawron \quad Zbigniew Pucha{\l}a\\
{The Institute of Theoretical and Applied Informatics}\\
{Polish Academy of Sciences},\\
{Ba{\l}tycka 5, 44-100 Gliwice, Poland}}
\maketitle
\begin{abstract}QI is a package of functions for Mathematica computer algebra system, which implements number of functions used in the analysis of quantum states and quantum operations. In contrast to many available packages for symbolic and numerical simulation of quantum computation presented package is focused on geometrical aspects of quantum information theory.\end{abstract}
\section{Kronecker sum and product, symbolic matrix}

\noindent\textbf{$ \text{SquareMatrixQ} $ }-- SquareMatrixQ[A] returns True only if A is a square matrix, and gives False otherwise.$  $\\[8pt]
\noindent\textbf{$ \text{SymbolicMatrix} $ }-- SymbolicMatrix[a,m,n] returns m$\times $n-matrix with elements a[i,j], i=1,...,m, j=1,...,n. If the third argument is ommited this function returns square m$\times $m matrix. This functions can save you some keystrokes and, thanks to TeXForm function, its results can be easily incorporated in LaTeX documents.$  $\\[8pt]
\noindent\textbf{$ \text{SymbolicVector} $ }-- SymbolicVector[a,n] is equivalent to Matrix[a,n,1] and it returns a vector with m elements a[i],i=1,...,n.$  $\\[8pt]
\noindent\textbf{$ \text{SymbolicHermitianMatrix} $ }-- SymbolicHermitianMatrix[sym,n] produces a n$\times $n Hermitian matrix. See also: SymbolicMatrix, SymbolicVector.$  $\\[8pt]
\noindent\textbf{$ \text{SymbolicBistochasticMatrix} $ }-- SymbolicBistochasticMatrix[sym, dim] produces symbolic bistochastic matrix size dim. See also: SymbolicMatrix, SymbolicVector.$  $\\[8pt]
\noindent\textbf{$ \text{ComplexToPoint} $ }-- ComplexToPoint[z] returns a real and an imaginary parts of a complex number z as a pair of real numbers.$  $\\[8pt]
\noindent\textbf{$ \text{MatrixSqrt} $ }-- MatrixSqrt[A] returns square root for the matrix A.$  $\\[8pt]
\noindent\textbf{$ \text{MatrixAbs} $ }-- MatrixAbs[A] returns absolute value for matrix A defined as MatrixSqrt[A.A$  ^{\dagger } $]. See also: MatrixSqrt.$  $\\[8pt]
\noindent\textbf{$ \text{MatrixRe} $ }-- Hermitian part of the matrix A i.e. $ \frac{1}{2}\text{(A+A} ^{\dagger }\text{).} $\\[8pt]
\noindent\textbf{$ \text{MatrixIm} $ }-- Antyhermitian part of the matrix A i.e. $ \frac{1}{2}\text{(A-A} ^{\dagger }\text{).} $\\[8pt]
\noindent\textbf{$ \text{Proj} $ }-- Proj[$\{$$ v_1,v_2 $,...,$ v_n $$\}$] returns projectors for the vectors in the input list.$  $\\[8pt]
\section{Fidelity, trace distance etc.}

\noindent\textbf{$ \text{Fidelity} $ }-- Fidelity[$ \rho _1,\rho _2 $] returns the quantum fidelity between states $ \rho _1 $ and $ \rho _2 $ calculated using a simplified formula as ($\sum $$ \lambda _i)^2 $, where $ \lambda _i $ are the eigenvalues of $ \rho _1\rho _2. $\\[8pt]
\noindent\textbf{$ \text{Superfidelity} $ }-- Superfidelity[$ \rho _1,\rho _2 $] calculates superfidelity between $ \rho _1 $ and $ \rho _2 $ defined as Tr[$ \rho _1.\rho _2 $] + Sqrt[1-Tr[$ \rho _1.\rho _1 $]]Sqrt[1-Tr[$ \rho _2.\rho _2 $]]. See: J.A. Miszczak et al., Quantum Information $\&$ Computation, Vol.9 No.1$\&$2 (2009).$  $\\[8pt]
\noindent\textbf{$ \text{Subfidelity} $ }-- Subfidelity[$ \rho _1,\rho _2 $] returns subfidelity between states $ \rho _1 $ and $ \rho _2 $ See: J.A. Miszczak et al., Quantum Information $\&$ Computation, Vol.9 No.1$\&$2 (2009).$  $\\[8pt]
\noindent\textbf{$ \text{TraceNorm} $ }-- TraceNorm[A] = $\sum $$ \sigma _i $, where $ \sigma _i $ are the singular values of A. See also: TraceDistance.$  $\\[8pt]
\noindent\textbf{$ \text{TraceDistance} $ }-- TraceDistance[$ \rho _1,\rho _2 $] returns the trace distance between matrices $ \rho _1 $ and $ \rho _2 $, which is defined as $ \frac{1}{2} $tr$|$$ \rho _1-\rho _2\text{$|$.} $\\[8pt]
\noindent\textbf{$ \text{GateFidelity} $ }-- GateFidelity[U,V] is equivalent to 1/d tr$|$UV$\dagger|$.$  $\\[8pt]
\section{Commonly used matrices}

\noindent\textbf{$ \text{sx} $ }-- Pauli matrix sx$  $\\[8pt]
\noindent\textbf{$ \text{sy} $ }-- Pauli matrix sy$  $\\[8pt]
\noindent\textbf{$ \text{sz} $ }-- Pauli matrix sz$  $\\[8pt]
\noindent\textbf{$ \text{id} $ }-- Identity matrix for one qubit. See also: IdentityMatrix.$  $\\[8pt]
\noindent\textbf{$ \text{wh} $ }-- Hadamard gate for one qubit. See also: QFT.$  $\\[8pt]
\noindent\textbf{$ \text{cnot} $ }-- Controlled not matrix for two qubits.$  $\\[8pt]
\section{Schmidt decomposition}

\noindent\textbf{$ \text{(*VectorSchmidtDecomposition} $ }-- $\$$Failed$  $\\[8pt]
\noindent\textbf{$ \text{OperatorSchmidtDecomposition} $ }-- OperatorSchmidtDecomposition$ \text{::} $usage$  $\\[8pt]
\noindent\textbf{$ \text{SchmidtDecomposition} $ }-- SchmidtDecomposition[e,dim] - accepts a vector or a matrix as a first argument and returns apropriate Schmidt decomposition. $  $\\[8pt]
\noindent\textbf{$ \text{$\texttt{"}$; (*TODO: Change SchmidtDecomposition} $ }-- $\$$Failed$  $\\[8pt]
\section{Reshaping, vectorization and reshuffling}

\noindent\textbf{$ \text{Vec} $ }-- Vec[A] - vectorization of the matrix A column by column. See also: Res.$  $\\[8pt]
\noindent\textbf{$ \text{Unvec} $ }-- Unvec[v,c] - de-vectorization of the vector into the matrixwith c columns. If the second parameter is omitted then it is assumed that v $\backslash $ncan be mapped into square matrix. See also: Unres, Vec.$  $\\[8pt]
\noindent\textbf{$ \text{Res} $ }-- Res[A] is equivalent to Vec[Transpose[A]]. Reshaping mapsmatrix A  into a vector row by row. Note, that this is different then thereshape operation in Matlab or GNU Octave.$  $\\[8pt]
\noindent\textbf{$ \text{Unres} $ }-- Unres[v,c] - de-reshaping of the vector into a matrix with c columns. If the second parameter is omitted then it is assumed that v can be mapped into a square matrix. See also: Unvec, Res.$  $\\[8pt]
\noindent\textbf{$ \text{Reshuffle} $ }-- Reshuffle[$\rho $, $\{$drows, dcols$\}$] for a matrix of dimensions (drows[[1]]$\times $drows[[2]])$\times $(dcols[[1]]$\times $dcols[[2]]) returns reshuffled matrix with dimensions (drows[[1]]$\times $dcols[[1]])$\times $(drows[[2]]$\times $dcols[[2]]), drows and dcols parameters can be ommited for a square matrix.$  $\\[8pt]
\section{Parametrizations}

\noindent\textbf{$ \text{Unitary2} $ }-- Unitary2[$\alpha $,$\beta $,$\gamma $,$\delta $] returns a parametrization of U(2).$  $\\[8pt]
\noindent\textbf{$ \text{Unitary2Euler} $ }-- Unitary2[$\alpha $,$\beta $,$\gamma $,$\delta $] returns the Euler parametrization of U(2).$  $\\[8pt]
\noindent\textbf{$ \text{SpecialUnitary2} $ }-- SpecialUnitary2[$\beta $,$\gamma $,$\delta $] returns a parametrization of SU(2). This is equivalent to Unitary2[0,$\beta $,$\gamma $,$\delta $].$  $\\[8pt]
\noindent\textbf{$ \text{Unitary3} $ }-- Unitary3[$\alpha $,$\beta $,$\gamma $,$\tau $,a,b,c,ph] returns the Euler parametrization of U(3).$  $\\[8pt]
\noindent\textbf{$ \text{Unitary4Canonical} $ }-- Parametrization of non-local unitary matrices for two qubits. See: B. Kraus, J.I. Cirac, Phys. Rev. A 63, 062309 (2001), quant-ph/0011050v1.$  $\\[8pt]
\noindent\textbf{$ \text{StateVector} $ }-- StateVector[$\{$$ \theta _1 $,...,$ \theta _n,\phi _{n+1} $,...,$ \phi _{2 n} $$\}$] returns pure n+1-dimensional pure state (ket vector) constructed form probability distribution parametrize by numbers $\{$$ \theta _1 $,...,$ \theta _n $$\}$ and phases $\{$$ \phi _1 $,...,$ \phi _n $$\}$. See also: SymbolicVector.$  $\\[8pt]
\section{One-qubit states}

\noindent\textbf{$ \text{QubitKet} $ }-- QubitKet[$\alpha $,$\beta $] parametrization of the pure state (as a state vector) for one qubit as (Cos[$\alpha $] Exp[i$\beta $], Sin[$\alpha $]). This is equivalent to StateVector[$\{\alpha $,$\beta \}$]. See also: QubitPureState, StateVector.$  $\\[8pt]
\noindent\textbf{$ \text{QubitPureState} $ }-- QubitPureState[$\alpha $,$\beta $] - a parametrization of the pure state as a density matrix for one qubit. This is just a alias for Proj[QubitKet[$\alpha $,$\beta $]]. See also: QubitKet.$  $\\[8pt]
\section{Quantum channels}

\noindent\textbf{$ \text{ApplyKraus} $ }-- ApplyKraus[ck,$\rho $] - apply channel ck, given as a list of Kraus operators, to the input state $\rho $. See also: ApplyUnitary, ApplyChannel.$  $\\[8pt]
\noindent\textbf{$ \text{ChannelToMatrix} $ }-- ChannelToMatrix[E,d] returns matrix representation of a channel E acting on d-dimensional state space. First argument should be a pure function E such that E[$\rho $] transforms input state according to the channel definition.$  $\\[8pt]
\noindent\textbf{$ \text{ApplyChannel} $ }-- ApplayChannel[f,$\rho $] - apply channel f, given as a pure function, to the input state $\rho $. See also: ApplyUnitary, ApplyKraus.$  $\\[8pt]
\noindent\textbf{$ \text{Superoperator} $ }-- Superoperator[kl] returns matrix representation of quantum channel given as a list of Kraus operators. Superoperator[fun,dim] is just am alternative name for ChannelToMatrix[fun,dim] and returns matrix representation of quantum channel, given as a pure function, acting on dim-dimensional space. So Superoperator[DepolarizingChannel[2,p,$\#$]$\&$,2] and Superoperator[QubitDepolarizingKraus[p]] returns the same matrix. See also: ChannelToMatrix.$  $\\[8pt]
\noindent\textbf{$ \text{DynamicalMatrix} $ }-- Dynamical matrix of quantum channel given as a list of Kraus operators (DynamicalMatrix[ch]) or as a function fun action on dim-dimensional space (DynamicalMatrix[fun,dim]). See also: Superoperator, ChannelToMatrix.$  $\\[8pt]
\noindent\textbf{$ \text{Jamiolkowski} $ }-- Jamiolkowski[K] gives the image of the Jamiolkowski isomorphism for the channel given as the list of Karus operators K. Jamiolkowski[fun,dim] gives the image of the Jamiolkowski isomorphism for the channel given as a function fun action on dim-dimensional space. See also: Superoperator, ChannelToMatrix, DynamicalMatrix.$  $\\[8pt]
\noindent\textbf{$ \text{TPChannelQ} $ }-- Performs some checks on Kraus operators. Use this if you want to check if they represent quantum channel.$  $\\[8pt]
\noindent\textbf{$ \text{SuperoperatorToKraus} $ }-- Finds Kraus operators for a given super operator$  $\\[8pt]
\noindent\textbf{$ \text{ProductSuperoperator} $ }-- ProductSuperoperator[$\Psi $,$\Phi $] computes a product superoperator of superoperatos $\Psi $ and $\Phi $.$  $\\[8pt]
\section{Partial trace and transposition}

\noindent\textbf{$ \text{PartialTranspose} $ }-- PartialTranspose[$\rho $,dim,sys] - Returns the partial transpose, according to systems sys, of density matrix $\rho $ composed of subsystems of dimensions dims.$  $\\[8pt]
\noindent\textbf{$ \text{PartialTrace} $ }-- PartialTrace[$\rho $,dim,sys] - Returns the partial trace, according to systems sys, of density matrix $\rho $ composed of subsystems of dimensions dim.$  $\\[8pt]
\section{Entanglement}

\section{Random states and operations}

\noindent\textbf{$ \text{RandomSimplex} $ }-- RandomSimplex[d] generates a point on a d-dimensional simplex according to the uniform distibution.$  $\\[8pt]
\noindent\textbf{$ \text{RandomKet} $ }-- RandomKet[d] - ...  random ket vector in d-dimensional space. d may be a list of integers in this case ket will be in product form d[[1]]$\otimes $...$\otimes $d[[k]]. See: T. Radtke, S. Fritzsche, Comp. Phys. Comm., Vol. 179, No. 9, p. 647-664.$  $\\[8pt]
\noindent\textbf{$ \text{RandomDynamicalMatrix} $ }-- RandomDynamicalMatrix[d,k] returns dynamical matrix of operation acting on d-dimensional states with k eigenvalues equal to 0. Thanks to Wojtek Bruzda. see Random Quantum Operations DOI[10.1016/j.physleta.2008.11.043]$  $\\[8pt]
\noindent\textbf{$ \text{GinibreMatrix} $ }-- GinibreMatrix[m,n] returns complex matrix of dimension m$\times $n with normal distribution of real and imaginary parts.$  $\\[8pt]
\noindent\textbf{$ \text{RandomSpecialUnitary} $ }-- Random special unitary matrix. See RandomUnitary$  $\\[8pt]
\noindent\textbf{$ \text{RandomUnitary} $ }-- Random unitary matrix using QR decomposition. F. Mezzadri, See: NOTICES of the AMS, Vol. 54 (2007), 592-604$  $\\[8pt]
\noindent\textbf{$ \text{RandomOrthogonal} $ }-- Random orthogonal matrix using QR decomposition. F. Mezzadri, See: NOTICES of the AMS, Vol. 54 (2007), 592-604$  $\\[8pt]
\noindent\textbf{$ \text{RandomState} $ }-- RandomState[d,dist] - random density matrix of dimension d. Argument dist can be ''HS'' (default value) or ''Bures'' or an integer K. ''HS'' gives uniform distribution with respect to the Hilbert-Schmidt measure. ''Bures'' gives random state distributed according to Bures measure. If dist is given as an integer K, the state is generated with respect to induced measure with an ancilla system od dimension K.$  $\\[8pt]
\section{Bloch Representation}

\noindent\textbf{$ \text{StateToBloch} $ }-- StateToBloch[A] - for a square matrix A returns a vector of coefficients obtained from expansion on normed generalized Pauli matrices. See also: GeneralizedPauliMatrices.$  $\\[8pt]
\noindent\textbf{$ \text{BlochToState} $ }-- BlochToState[v] - returns a matrix of appropriate dimension from Bloch vector, i.e. coefficients treated as coefficients from expansion on normalized generalized Pauli matrices. See also: GeneralizedPauliMatrices.$  $\\[8pt]


\end{document}