(* Content-type: application/mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 7.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       145,          7]
NotebookDataLength[     95818,       2869]
NotebookOptionsPosition[     91040,       2727]
NotebookOutlinePosition[     91426,       2744]
CellTagsIndexPosition[     91383,       2741]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{

Cell[CellGroupData[{
Cell["Quantum information related functions", "Title"],

Cell[CellGroupData[{

Cell["Kronecker sum and product, symbolic matrix", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"x_", "\[CircleTimes]", "y_"}], " ", ":=", " ", 
   RowBox[{"KroneckerProduct", "[", 
    RowBox[{"x", ",", "y"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"x_", "\[CircleTimes]", "y_", "\[CircleTimes]", "z_"}], " ", ":=", 
   " ", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{"x", "\[CircleTimes]", "y"}], ")"}], "\[CircleTimes]", "z"}]}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"KroneckerSum", "[", 
    RowBox[{"A_", ",", "B_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", "=", 
       RowBox[{"Length", "[", "A", "]"}]}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"KroneckerProduct", "[", 
       RowBox[{"A", ",", 
        RowBox[{"IdentityMatrix", "[", "dim", "]"}]}], "]"}], "+", 
      RowBox[{"KroneckerProduct", "[", 
       RowBox[{
        RowBox[{"IdentityMatrix", "[", "dim", "]"}], ",", "B"}], "]"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"x_", "\[CirclePlus]", "y_"}], ":=", 
   RowBox[{"KroneckerSum", "[", 
    RowBox[{"x", ",", "y"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"x_", "\[CirclePlus]", "y_", "\[CirclePlus]", "z_"}], ":=", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{"x", "\[CirclePlus]", "y"}], ")"}], "\[CirclePlus]", "z"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"KroneckerSum", "::", "usage"}], " ", "=", " ", 
   "\"\<KroneckerSum[A,B] returns the Kronecker sum of A and B defined as A\
\[CircleTimes]1+1\[CircleTimes]B. Alternative syntax A\[CirclePlus]B for \
KroneckerSum[A,B] is provided.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"SymbolicMatrix", "[", 
    RowBox[{"sym_", ",", "d1_", ",", 
     RowBox[{"d2_:", "0"}]}], "]"}], ":=", "\[IndentingNewLine]", 
   RowBox[{"Which", "[", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"d2", "\[Equal]", "0"}], ",", 
     RowBox[{"Table", "[", 
      RowBox[{
       SubscriptBox["sym", 
        RowBox[{"i", ",", "j"}]], ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", "1", ",", "d1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"j", ",", "1", ",", "d1"}], "}"}]}], "]"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"d2", "\[Equal]", "1"}], ",", 
     RowBox[{"Table", "[", 
      RowBox[{
       SubscriptBox["sym", "i"], ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", "1", ",", "d1"}], "}"}]}], "]"}], ",", 
     "\[IndentingNewLine]", "True", ",", 
     RowBox[{"Table", "[", 
      RowBox[{
       SubscriptBox["sym", 
        RowBox[{"i", ",", "j"}]], ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", "1", ",", "d1"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"j", ",", "1", ",", "d2"}], "}"}]}], "]"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"SymbolicMatrix", "::", "usage"}], " ", "=", " ", 
   "\"\<SymbolicMatrix[a,m,n] returns m\[Cross]n-matrix with elements \
\!\(\*SubscriptBox[\(a\), \(i, j\)]\), i=1,...,m, j=1,...,n. If the second \
argument is ommited this function returns square n\[Cross]n matrix. This \
functions can save you some keystrokes and, thanks to TeXForm function, its \
results can be easily incorporeted in LaTeX documents.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"SymbolicVector", "[", 
    RowBox[{"sym_", ",", "d1_"}], "]"}], ":=", 
   RowBox[{"SymbolicMatrix", "[", 
    RowBox[{"sym", ",", "d1", ",", "1"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"SymbolicVector", "::", "usage"}], " ", "=", " ", 
   "\"\<SymbolicVectors[a,m] is equavalent to Matrix[a,m,1] and it returns a \
vector with m elements \!\(\*SubscriptBox[\(a\), \(i\)]\),i=1,...,m, \
j=1,...,n. This function is usefoul, for example, for generating lists of \
parameters.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ComplexToPoint", "[", "z_", "]"}], ":=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Re", "[", "z", "]"}], ",", 
     RowBox[{"Im", "[", "z", "]"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ComplexToPoint", "::", "usage"}], " ", "=", " ", 
   "\"\<ComplexToPoint[z] returns real and imaginary parts of a complex \
number z as a pair of real numbers (point in \!\(\*SuperscriptBox[\(R\), \
\(2\)]\)).\>\""}], ";"}]}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Fidelity, trace distance etc.", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"MatrixSqrt", "[", "a_", "]"}], ":=", 
   RowBox[{"MatrixPower", "[", 
    RowBox[{"a", ",", 
     RowBox[{"1", "/", "2"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"MatrixSqrt", "::", "usage"}], "=", " ", 
   "\"\<MatrixSqrt[m] - square root for the matrix m.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"MatrixAbs", "[", "a_", "]"}], ":=", 
   RowBox[{"MatrixSqrt", "[", 
    RowBox[{"a", ".", 
     RowBox[{"a", "\[ConjugateTranspose]"}]}], "]"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"MatrixAbs", "::", "usage"}], "=", " ", 
   "\"\<MatrixAbs[m] - absolute value for matrix m calculated as \
MatrixSqrt[m.m\[ConjugateTranspose]].\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Fidelity", "[", 
    RowBox[{"a_", ",", "b_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"sqrt", "=", 
       RowBox[{"MatrixSqrt", "[", "a", "]"}]}], "}"}], ",", 
     RowBox[{
      RowBox[{"Tr", "[", 
       RowBox[{"MatrixSqrt", "[", 
        RowBox[{"sqrt", ".", "b", ".", "sqrt"}], "]"}], "]"}], "^", "2"}]}], 
    "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Fidelity", "::", "usage"}], " ", "=", " ", 
   "\"\<Fidelity[\!\(\*SubscriptBox[\(\[Rho]\), \
\(1\)]\),\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)] returns quantum fidelity \
between states \!\(\*SubscriptBox[\(\[Rho]\), \(1\)]\) and \
\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Superfidelity", "[", 
    RowBox[{"a_", ",", "b_"}], "]"}], ":=", 
   RowBox[{
    RowBox[{"Tr", "[", 
     RowBox[{"a", ".", "b"}], "]"}], " ", "+", " ", 
    RowBox[{
     RowBox[{"\[Sqrt]", 
      RowBox[{"(", 
       RowBox[{"1", "-", 
        RowBox[{"Tr", "[", 
         RowBox[{"a", ".", "a"}], "]"}]}], ")"}]}], 
     RowBox[{"\[Sqrt]", 
      RowBox[{"(", 
       RowBox[{"1", "-", 
        RowBox[{"Tr", "[", 
         RowBox[{"b", ".", "b"}], "]"}]}], ")"}]}]}]}]}], " ", 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Superfidelity", "::", "usage"}], " ", "=", " ", 
   "\"\<Superfidelity[\!\(\*SubscriptBox[\(\[Rho]\), \
\(1\)]\),\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)] returns superfidelity \
between states \!\(\*SubscriptBox[\(\[Rho]\), \(1\)]\) and \
\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\) calculated as \!\(\*SubscriptBox[\(tr\
\[Rho]\), \(1\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \
\(2\)]\)+\[Sqrt](1-\!\(\*SubscriptBox[\(tr\[Rho]\), \
\(1\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \(1\)]\))\[Sqrt](1-\!\(\*SubscriptBox[\
\(tr\[Rho]\), \(2\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)).\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Subfidelity", "[", 
    RowBox[{"a_", ",", "b_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"prod", " ", "=", " ", 
       RowBox[{"a", ".", "b"}]}], "}"}], ",", 
     RowBox[{
      RowBox[{"Tr", "[", "prod", "]"}], " ", "+", 
      RowBox[{
       RowBox[{"\[Sqrt]", "2"}], 
       RowBox[{"\[Sqrt]", 
        RowBox[{"(", 
         RowBox[{
          RowBox[{
           RowBox[{"Tr", "[", "prod", "]"}], "^", "2"}], "-", 
          RowBox[{"Tr", "[", 
           RowBox[{"prod", ".", "prod"}], "]"}]}], ")"}]}]}]}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Subfidelity", "::", "usage"}], " ", "=", " ", 
   "\"\<Subfidelity[\!\(\*SubscriptBox[\(\[Rho]\), \
\(1\)]\),\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)] returns subfidelity between \
states \!\(\*SubscriptBox[\(\[Rho]\), \(1\)]\) and \
\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\) calculated as \!\(\*SubscriptBox[\(tr\
\[Rho]\), \(1\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)+\[Sqrt]2\[Sqrt]((\!\
\(\*SubscriptBox[\(tr\[Rho]\), \(2\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \
\(2\)]\))-\!\(\*SubscriptBox[\(tr\[Rho]\), \
\(1\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \
\(1\)]\)\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"TraceDistance", "[", 
    RowBox[{"a_", ",", "b_"}], "]"}], ":=", 
   RowBox[{
    RowBox[{"1", "/", "2"}], 
    RowBox[{"Tr", "[", 
     RowBox[{"MatrixAbs", "[", 
      RowBox[{"a", "-", "b"}], "]"}], "]"}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"TraceDistance", "::", "usage"}], " ", "=", " ", 
   "\"\<TraceDistance[\!\(\*SubscriptBox[\(\[Rho]\), \
\(1\)]\),\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)] = 1/2tr|\!\(\*SubscriptBox[\
\(\[Rho]\), \(1\)]\)-\!\(\*SubscriptBox[\(\[Rho]\), \(2\)]\)|.\>\""}], 
  ";"}]}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Commonly used matrices", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"sx", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0"}], "}"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"sy", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", 
       RowBox[{"-", "\[ImaginaryI]"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\[ImaginaryI]", ",", "0"}], "}"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"sz", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", 
       RowBox[{"-", "1"}]}], "}"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"\[Sigma]x", " ", "=", " ", "sx"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"\[Sigma]y", " ", "=", " ", "sy"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"\[Sigma]z", " ", "=", " ", "sz"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"id", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1"}], "}"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"wh", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", 
       RowBox[{"-", "1"}]}], "}"}]}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"sx", "::", "usage"}], " ", "=", " ", 
   "\"\<Pauli matrix \!\(\*SubscriptBox[\(\[Sigma]\), \(x\)]\).\>\""}], 
  ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"sy", "::", "usage"}], " ", "=", " ", 
   "\"\<Pauli matrix \!\(\*SubscriptBox[\(\[Sigma]\), \(y\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"sz", "::", "usage"}], " ", "=", " ", 
   "\"\<Pauli matrix \!\(\*SubscriptBox[\(\[Sigma]\), \(z\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Sigma]x", "::", "usage"}], "=", 
   RowBox[{"sx", "::", "usage"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Sigma]y", "::", "usage"}], "=", 
   RowBox[{"sy", "::", "usage"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Sigma]z", "::", "usage"}], "=", 
   RowBox[{"sz", "::", "usage"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"id", "::", "usage"}], "  ", "=", " ", 
   "\"\<Identity matrix for one qubit.\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"wh", "::", "usage"}], " ", "=", " ", 
   "\"\<Hadamard gate for one qubit.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"\[Lambda]1", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0"}], "}"}]}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"\[Lambda]2", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", 
       RowBox[{"-", "\[ImaginaryI]"}], ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\[ImaginaryI]", ",", "0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0"}], "}"}]}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"\[Lambda]3", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", 
       RowBox[{"-", "1"}], ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0"}], "}"}]}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"\[Lambda]4", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "0"}], "}"}]}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"\[Lambda]5", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", 
       RowBox[{"-", "\[ImaginaryI]"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\[ImaginaryI]", ",", "0", ",", "0"}], "}"}]}], "}"}]}], 
  ";"}], "\n", 
 RowBox[{
  RowBox[{"\[Lambda]6", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1", ",", "0"}], "}"}]}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"\[Lambda]7", "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "0", ",", 
       RowBox[{"-", "\[ImaginaryI]"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "\[ImaginaryI]", ",", "0"}], "}"}]}], "}"}]}], 
  ";"}], "\n", 
 RowBox[{
  RowBox[{"\[Lambda]8", "=", 
   RowBox[{
    RowBox[{"Sqrt", "[", 
     RowBox[{"1", "/", "3"}], "]"}], 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"1", ",", "0", ",", "0"}], "}"}], ",", 
      RowBox[{"{", 
       RowBox[{"0", ",", "1", ",", "0"}], "}"}], ",", 
      RowBox[{"{", 
       RowBox[{"0", ",", "0", ",", 
        RowBox[{"-", "2"}]}], "}"}]}], "}"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]1", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(1\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]2", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(2\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]3", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(3\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]4", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(4\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]5", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(5\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]6", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(6\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]7", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(7\)]\).\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]8", "::", "usage"}], " ", "=", " ", 
   "\"\<Gell-Mann matrix \!\(\*SubscriptBox[\(\[Lambda]\), \(8\)]\).\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Proj", "[", "v_", "]"}], ":=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"v", "[", 
       RowBox[{"[", "i", "]"}], "]"}], 
      RowBox[{"Conjugate", "[", 
       RowBox[{"v", "[", 
        RowBox[{"[", "j", "]"}], "]"}], "]"}]}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", 
       RowBox[{"Length", "[", "v", "]"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", 
       RowBox[{"Length", "[", "v", "]"}]}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Proj", "::", "usage"}], " ", "=", " ", 
   "\"\<Proj[{v1,...,v2}] returns projectors for the vectors in the input \
list.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"BaseVectors", "[", "n_Integer", "]"}], ":=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"IdentityMatrix", "[", "n", "]"}], "[", 
      RowBox[{"[", "k", "]"}], "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"k", ",", "1", ",", "n"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"BaseVectors", "::", "usage"}], " ", "=", " ", 
   "\"\<BaseVectors[n] - canonical basis in n-dimensional Hilbert \
space\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"BaseMatrices", "[", "n_Integer", "]"}], ":=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"Unres", "[", 
      RowBox[{
       RowBox[{"BaseVectors", "[", 
        RowBox[{"n", "^", "2"}], "]"}], "[", 
       RowBox[{"[", "k", "]"}], "]"}], "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"k", ",", "1", ",", 
       RowBox[{"n", "^", "2"}]}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"BaseMatrices", "::", "usage"}], " ", "=", " ", 
   "\"\<BaseMatrices[n] - canonical basis in n\[Cross]n-dimensional \
Hilbert-Schmidt space.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"KroneckerDeltaMatrix", "[", 
   RowBox[{"m_", ",", "n_", ",", "dim_"}], "]"}], ":=", 
  RowBox[{"Block", "[", 
   RowBox[{
    RowBox[{"{", "mtx", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"mtx", "=", 
      RowBox[{"Table", "[", 
       RowBox[{"0", ",", 
        RowBox[{"{", "dim", "}"}], ",", 
        RowBox[{"{", "dim", "}"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"mtx", "[", 
       RowBox[{"[", 
        RowBox[{"m", ",", "n"}], "]"}], "]"}], "=", "1"}], ";", 
     "\[IndentingNewLine]", "mtx"}]}], "]"}]}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"KroneckerDeltaMatrix", "::", "usage"}], " ", "=", " ", 
   "\"\<KroneckerDeltaMatrix[i,j,d] returns d\[Cross]d matrix with 1 at \
position (i,j) and zeroes elsewhere.\>\""}], ";"}]}], "Input",
 CellChangeTimes->{{3.451965208830434*^9, 3.451965366213861*^9}, 
   3.451965432138916*^9}],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Lambda1", "[", 
    RowBox[{"i_", " ", ",", "j_", ",", "n_"}], "]"}], ":=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{
      RowBox[{
       RowBox[{"KroneckerDelta", "[", 
        RowBox[{"j", ",", "\[Mu]"}], "]"}], 
       RowBox[{"KroneckerDelta", "[", 
        RowBox[{"i", ",", "\[Nu]"}], "]"}]}], " ", "+", " ", 
      RowBox[{
       RowBox[{"KroneckerDelta", "[", 
        RowBox[{"j", ",", "\[Nu]"}], "]"}], 
       RowBox[{"KroneckerDelta", "[", 
        RowBox[{"i", ",", "\[Mu]"}], "]"}]}]}], " ", ",", 
     RowBox[{"{", 
      RowBox[{"\[Mu]", ",", "1", ",", "n"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\[Nu]", ",", "1", ",", "n"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Lambda1", "::", "usage"}], " ", "=", " ", 
   "\"\<Lambda1[i,j,n] generalized Pauli matrix {\!\(\*SubscriptBox[\(\
\[Lambda]\), \(1\)]\)(i,j)\!\(\*SubscriptBox[\(}\), \(k, \
l\)]\)=\!\(\*SubscriptBox[\(\[Delta]\), \
\(jk\)]\)\!\(\*SubscriptBox[\(\[Delta]\), \(il\)]\)+\!\(\*SubscriptBox[\(\
\[Delta]\), \(jl\)]\)\!\(\*SubscriptBox[\(\[Delta]\), \(ik\)]\) for i<j. For \
example Lambda1[1,2,2] is equal to Pauli \!\(\*SubscriptBox[\(\[Sigma]\), \(x\
\)]\).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Lambda2", "[", 
    RowBox[{"i_", " ", ",", "j_", ",", "n_"}], "]"}], ":=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"-", "\[ImaginaryI]"}], 
      RowBox[{"(", 
       RowBox[{
        RowBox[{
         RowBox[{"KroneckerDelta", "[", 
          RowBox[{"i", ",", "\[Mu]"}], "]"}], 
         RowBox[{"KroneckerDelta", "[", 
          RowBox[{"j", ",", "\[Nu]"}], "]"}]}], " ", "-", " ", 
        RowBox[{
         RowBox[{"KroneckerDelta", "[", 
          RowBox[{"i", ",", "\[Nu]"}], "]"}], 
         RowBox[{"KroneckerDelta", "[", 
          RowBox[{"j", ",", "\[Mu]"}], "]"}]}]}], ")"}]}], " ", ",", 
     RowBox[{"{", 
      RowBox[{"\[Mu]", ",", "1", ",", "n"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"\[Nu]", ",", "1", ",", "n"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Lambda2", "::", "usage"}], " ", "=", " ", 
   "\"\<Lambda2[i,j,n] generalized Pauli matrix {\!\(\*SubscriptBox[\(\
\[Lambda]\), \(2\)]\)(i,j)\!\(\*SubscriptBox[\(}\), \(k, \
l\)]\)=-\[ImaginaryI](\!\(\*SubscriptBox[\(\[Delta]\), \
\(ik\)]\)\!\(\*SubscriptBox[\(\[Delta]\), \(jl\)]\)-\!\(\*SubscriptBox[\(\
\[Delta]\), \(il\)]\)\!\(\*SubscriptBox[\(\[Delta]\), \(jk\)]\)) for i<j. For \
example Lambda2[1,2,2] is equal to \!\(\*SubscriptBox[\(\[Sigma]\), \(y\)]\).\
\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Lambda3", "[", 
    RowBox[{"i_", ",", "n_"}], "]"}], ":=", 
   RowBox[{
    RowBox[{"Sqrt", "[", 
     RowBox[{"2", "/", 
      RowBox[{"(", 
       RowBox[{
        RowBox[{"i", "^", "2"}], "-", "i"}], ")"}]}], "]"}], 
    RowBox[{"DiagonalMatrix", "[", 
     RowBox[{"Join", "[", 
      RowBox[{
       RowBox[{"Append", "[", 
        RowBox[{
         RowBox[{"Table", "[", 
          RowBox[{"1", ",", 
           RowBox[{"{", 
            RowBox[{"i", "-", "1"}], "}"}]}], "]"}], ",", 
         RowBox[{"-", 
          RowBox[{"(", 
           RowBox[{"i", "-", "1"}], ")"}]}]}], "]"}], ",", 
       RowBox[{"Table", "[", 
        RowBox[{"0", ",", 
         RowBox[{"{", 
          RowBox[{"n", "-", "i"}], "}"}]}], "]"}]}], "]"}], "]"}]}]}], 
  ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"Lambda3", "::", "usage"}], " ", "=", 
   "\"\<Lambda3[i,n] generalized Pauli matrix {\!\(\*SubscriptBox[\(\[Lambda]\
\), \(3\)]\)}= \[Sqrt](\!\(\*FractionBox[\(2\), \(\*SuperscriptBox[\(n\), \(2\
\)] - n\)]\))diag(1,1,...,-1,0,...0), with -1 at n-th position, for \
i=2,...,n. For example Lambda3[2,2] is equal to \!\(\*SubscriptBox[\(\[Sigma]\
\), \(z\)]\).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"GeneralizedPauliMatrices", "[", "n_", "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"l1", ",", "l2", ",", "l3", ",", "i", ",", "j"}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"l1", "=", 
       RowBox[{"Flatten", "[", 
        RowBox[{
         RowBox[{"Table", "[", 
          RowBox[{
           RowBox[{"Lambda1", "[", 
            RowBox[{"i", ",", "j", ",", "n"}], "]"}], ",", 
           RowBox[{"{", 
            RowBox[{"i", ",", "1", ",", "n"}], "}"}], ",", 
           RowBox[{"{", 
            RowBox[{"j", ",", 
             RowBox[{"i", "+", "1"}], ",", "n"}], "}"}]}], "]"}], ",", "1"}], 
        "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"l2", "=", 
       RowBox[{"Flatten", "[", 
        RowBox[{
         RowBox[{"Table", "[", 
          RowBox[{
           RowBox[{"Lambda2", "[", 
            RowBox[{"i", ",", "j", ",", "n"}], "]"}], ",", 
           RowBox[{"{", 
            RowBox[{"i", ",", "1", ",", "n"}], "}"}], ",", 
           RowBox[{"{", 
            RowBox[{"j", ",", 
             RowBox[{"i", "+", "1"}], ",", "n"}], "}"}]}], "]"}], ",", "1"}], 
        "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"l3", "=", 
       RowBox[{"Table", "[", 
        RowBox[{
         RowBox[{"Lambda3", "[", 
          RowBox[{"i", ",", "n"}], "]"}], ",", 
         RowBox[{"{", 
          RowBox[{"i", ",", "2", ",", "n"}], "}"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"Join", "[", 
       RowBox[{"l1", ",", "l2", ",", "l3"}], "]"}]}]}], "\[IndentingNewLine]",
     "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"GeneralizedPauliMatrices", "::", "usage"}], " ", "=", " ", 
   "\"\<GeneralizedPauliMatrices[n] - list of generalized Pauli matrices for \
SU(n). For n=2 these are just Pauli matrices and for n=3 - Gell-Mann \
matrices. Note that identity matrix is not included in the list. See also: \
PauliMatrices, GellMannMatrices, \[Lambda], Lambda1, Lambda2, Lambda3.\>\""}],
   ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]", "[", 
    RowBox[{"i_", ",", "n_"}], "]"}], ":=", 
   RowBox[{
    RowBox[{"GeneralizedPauliMatrices", "[", "n", "]"}], "[", 
    RowBox[{"[", "i", "]"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Lambda]", "::", "usage"}], " ", "=", " ", 
   "\"\<\[Lambda][i,n] is defined as GeneralizedPauliMatrices[n][[i]].\>\""}],
   ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"PauliMatrices", "=", 
   RowBox[{"{", 
    RowBox[{"sx", ",", "sy", ",", "sz"}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"PauliMatrices", "::", "usage"}], " ", "=", " ", 
   "\"\<List of Pauli matrices. Use Map[MatrixForm[#]&,PauliMatrices] to get \
this list in more readible form.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"GellMannMatrices", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
    "\[Lambda]1", ",", "\[Lambda]2", ",", "\[Lambda]3", ",", "\[Lambda]4", 
     ",", "\[Lambda]5", ",", "\[Lambda]6", ",", "\[Lambda]7", ",", 
     "\[Lambda]8"}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"GellMannMatrices", "::", "usage"}], " ", "=", " ", 
   "\"\<List of Gell-Mann matrices. Use Map[MatrixForm[#]&,GellMannMatrices] \
to get this list in more readible form.\>\""}], ";"}]}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Quantum gates", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Swap", "[", "dim_", "]"}], ":=", 
   RowBox[{"Plus", "@@", 
    RowBox[{"Flatten", "[", 
     RowBox[{
      RowBox[{"Table", "[", 
       RowBox[{
        RowBox[{"KroneckerProduct", "[", 
         RowBox[{
          RowBox[{"Ketbra", "[", 
           RowBox[{"i", ",", "j", ",", "dim"}], "]"}], ",", 
          RowBox[{"Ketbra", "[", 
           RowBox[{"j", ",", "i", ",", "dim"}], "]"}]}], "]"}], ",", 
        RowBox[{"{", 
         RowBox[{"i", ",", "0", ",", 
          RowBox[{"dim", "-", "1"}]}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{"j", ",", "0", ",", 
          RowBox[{"dim", "-", "1"}]}], "}"}]}], "]"}], ",", "1"}], "]"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Swap", "::", "usage"}], "=", 
   "\"\<Swap[n] returns permutation operator \
\!\(\*UnderoverscriptBox[\(\[Sum]\), \(i = 0\), \(n - \
1\)]\)\!\(\*UnderoverscriptBox[\(\(\\\ \)\(\[Sum]\)\), \(j = 0\), \(n - \
1\)]\)|i\[RightAngleBracket]\[LeftAngleBracket]j|\[CircleTimes]|j\
\[RightAngleBracket]\[LeftAngleBracket]i\[VerticalSeparator] acting on \
\!\(\*SuperscriptBox[\(n\), \(2\)]\)-dimensional space and exchanging two \
n-dimensional subsystems.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QFT", "[", 
    RowBox[{"n_", ",", 
     RowBox[{"method_:", "\"\<Symbolic\>\""}]}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", "\[Omega]", "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"If", " ", "[", 
       RowBox[{
        RowBox[{"method", "\[Equal]", "\"\<Numerical\>\""}], ",", 
        RowBox[{"\[Omega]", "=", 
         RowBox[{"N", "[", 
          RowBox[{"Exp", "[", 
           RowBox[{"2", " ", "\[Pi]", " ", 
            RowBox[{"\[ImaginaryI]", "/", "n"}]}], "]"}], "]"}]}], ",", 
        RowBox[{"\[Omega]", "=", 
         RowBox[{"Exp", "[", 
          RowBox[{"2", " ", "\[Pi]", " ", 
           RowBox[{"\[ImaginaryI]", "/", "n"}]}], "]"}]}]}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"Table", "[", 
       RowBox[{
        SuperscriptBox["\[Omega]", 
         RowBox[{"i", " ", "k"}]], " ", ",", 
        RowBox[{"{", 
         RowBox[{"i", ",", "1", ",", "n"}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{"k", ",", "1", ",", "n"}], "}"}]}], "]"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QFT", "::", "usage"}], " ", "=", " ", 
   "\"\<QFT[n,method] - quantum Fourier transform of dimension n. This \
function accepts second optional argument, which specifices method used in \
calculation. Parameter method can be equal to \\\"Symbloic\\\", which is \
default, or \\\"Numerical\\\". The second option makes this function much \
faster.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"CNot", "=", 
   RowBox[{
    RowBox[{
     RowBox[{"Ketbra", "[", 
      RowBox[{"1", ",", "1", ",", "2"}], "]"}], "\[CircleTimes]", "sx"}], "+", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{
       RowBox[{"IdentityMatrix", "[", "2", "]"}], "-", 
       RowBox[{"Ketbra", "[", 
        RowBox[{"1", ",", "1", ",", "2"}], "]"}]}], ")"}], "\[CircleTimes]", 
     RowBox[{"IdentityMatrix", "[", "2", "]"}]}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"CNot", "::", "usage"}], " ", "=", " ", 
   "\"\<Controlled not matrix for two qubits.\>\""}], ";"}]}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Spacial states ", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Ket", "[", 
    RowBox[{"label_", ",", "dim_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", "vec", "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"If", "[", 
      RowBox[{
       RowBox[{"label", "<", "dim"}], ",", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"vec", " ", "=", 
         RowBox[{"Table", "[", 
          RowBox[{"0", ",", 
           RowBox[{"{", "dim", "}"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"vec", "[", 
          RowBox[{"[", 
           RowBox[{"label", "+", "1"}], "]"}], "]"}], "=", "1"}], ";", 
        "\[IndentingNewLine]", "vec"}]}], "\[IndentingNewLine]", "]"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Ket", "::", "usage"}], " ", "=", " ", 
   "\"\<Ket[i,d] returns |i\[RightAngleBracket] in d-dimensinal Hilbert \
space.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Ketbra", "[", 
    RowBox[{"i_", ",", "j_", ",", "dim_"}], "]"}], ":=", 
   RowBox[{"KroneckerProduct", "[", 
    RowBox[{
     RowBox[{"Ket", "[", 
      RowBox[{"i", ",", "dim"}], "]"}], ",", 
     RowBox[{"Ket", "[", 
      RowBox[{"j", ",", "dim"}], "]"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Ketbra", "::", "usage"}], " ", "=", " ", 
   "\"\<Ketbra[i,j,d] returns \[VerticalSeparator]i\[RightAngleBracket]\
\[LeftAngleBracket]j\[VerticalSeparator] ascting on d-dimensional \
space.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"MaxMix", "[", "n_", "]"}], ":=", 
   RowBox[{
    FractionBox["1", "n"], 
    RowBox[{"IdentityMatrix", "[", "n", "]"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"MaxMix", "::", "usage"}], " ", "=", " ", 
   "\"\<MaxMix[n] gies maximally mixed state in n-dimensional space of \
density matrices.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"MaxEnt", "[", "dim_", "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"subDim", "=", 
       RowBox[{"Sqrt", "[", "dim", "]"}]}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"If", "[", 
      RowBox[{
       RowBox[{"IntegerQ", " ", "[", "subDim", "]"}], ",", 
       RowBox[{
        FractionBox["1", 
         RowBox[{"Sqrt", "[", "subDim", "]"}]], 
        RowBox[{"Plus", "@@", 
         RowBox[{"Table", "[", 
          RowBox[{
           RowBox[{"Flatten", "[", 
            RowBox[{
             RowBox[{"{", 
              RowBox[{"Ket", "[", 
               RowBox[{"i", ",", "subDim"}], "]"}], "}"}], "\[CircleTimes]", 
             RowBox[{"Ket", "[", 
              RowBox[{"i", ",", "subDim"}], "]"}]}], "]"}], ",", 
           RowBox[{"{", 
            RowBox[{"i", ",", "0", ",", 
             RowBox[{"subDim", "-", "1"}]}], "}"}]}], "]"}]}]}]}], "]"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"MaxEnt", "::", "usage"}], " ", "=", " ", 
   "\"\<MaxEnt[N] - maximally entangled state \!\(\*FractionBox[\(1\), \(\
\[Sqrt]N\)]\) \!\(\*UnderoverscriptBox[\(\[Sum]\), \(i = 0\), \(n - 1\)]\)|i\
\[RightAngleBracket]\[CircleTimes]|i\[RightAngleBracket] with N = \
\!\(\*SuperscriptBox[\(n\), \(2\)]\).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"WernerState", "[", 
    RowBox[{"p_", ",", "dim_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"subDim", "=", 
        RowBox[{"\[Sqrt]", "dim"}]}], ",", "permut"}], "}"}], ",", 
     RowBox[{"If", "[", 
      RowBox[{
       RowBox[{"IntegerQ", "[", "subDim", "]"}], ",", 
       RowBox[{
        RowBox[{"permut", "=", 
         RowBox[{"Swap", "[", "subDim", "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{
          RowBox[{"p", "/", 
           RowBox[{"(", 
            RowBox[{"subDim", " ", 
             RowBox[{"(", 
              RowBox[{"subDim", "+", "1"}], ")"}]}], ")"}]}], " ", 
          RowBox[{"(", 
           RowBox[{
            RowBox[{"IdentityMatrix", "[", "dim", "]"}], "+", "permut"}], 
           ")"}]}], "+", 
         RowBox[{
          RowBox[{"(", 
           RowBox[{"1", "-", "p"}], ")"}], " ", 
          RowBox[{
           RowBox[{"(", 
            RowBox[{"1", "-", "p"}], ")"}], "/", 
           RowBox[{"(", 
            RowBox[{"subDim", " ", 
             RowBox[{"(", 
              RowBox[{"subDim", "-", "1"}], ")"}]}], ")"}]}], " ", 
          RowBox[{"(", 
           RowBox[{
            RowBox[{"IdentityMatrix", "[", "dim", "]"}], "-", "permut"}], 
           ")"}]}]}]}]}], "]"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"WernerState", "::", "usage"}], "=", " ", 
   "\"\<WernerState[p,n] - Werner state with parameter p\[Element][0,1] for n\
\[Cross]n-dimensional system. This state is defined as p \
\!\(\*FractionBox[\(2\), \(n \((n + 1)\)\)]\)\!\(\*SubscriptBox[\(P\), \
\(sym\)]\) + (1-p) \!\(\*FractionBox[\(2\), \(n \((n - \
1)\)\)]\)\!\(\*SubscriptBox[\(P\), \(snty\)]\), where \
\!\(\*SubscriptBox[\(P\), \(sym\)]\) and \!\(\*SubscriptBox[\(P\), \
\(snty\)]\) are projectors for symmetric and anty-symmetric subspace.\>\""}], 
  ";"}]}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Schmidt decomposition", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"SchmidtDecomposition", "[", 
    RowBox[{"vec_", ",", "d1_", ",", "d2_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"mtx", ",", "svd", ",", "vals", ",", 
       RowBox[{"snum", "=", 
        RowBox[{"Min", "[", 
         RowBox[{"d1", ",", "d2"}], "]"}]}]}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"mtx", " ", "=", " ", 
       RowBox[{"Table", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"(", 
           RowBox[{"Flatten", "[", 
            RowBox[{
             RowBox[{"{", 
              RowBox[{
               RowBox[{"BaseVectors", "[", "d1", "]"}], "[", 
               RowBox[{"[", "i", "]"}], "]"}], "}"}], "\[CircleTimes]", 
             RowBox[{
              RowBox[{"BaseVectors", "[", "d2", "]"}], "[", 
              RowBox[{"[", "j", "]"}], "]"}]}], "]"}], ")"}], ".", "vec"}], 
         ",", 
         RowBox[{"{", 
          RowBox[{"i", ",", "1", ",", "d1"}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"j", ",", "1", ",", "d2"}], "}"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"svd", "=", 
       RowBox[{"SingularValueDecomposition", "[", "mtx", "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"vals", "=", 
       RowBox[{"Select", "[", 
        RowBox[{
         RowBox[{"Diagonal", "[", 
          RowBox[{"svd", "[", 
           RowBox[{"[", "2", "]"}], "]"}], "]"}], ",", 
         RowBox[{
          RowBox[{"#", "\[NotEqual]", "0"}], "&"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"snum", "=", 
       RowBox[{"Length", "[", "vals", "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"Table", "[", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{
          RowBox[{"vals", "[", 
           RowBox[{"[", "i", "]"}], "]"}], ",", 
          RowBox[{
           RowBox[{"svd", "[", 
            RowBox[{"[", "1", "]"}], "]"}], ".", 
           RowBox[{
            RowBox[{"BaseVectors", "[", "d1", "]"}], "[", 
            RowBox[{"[", "i", "]"}], "]"}]}], ",", 
          RowBox[{
           RowBox[{
            RowBox[{"svd", "[", 
             RowBox[{"[", "3", "]"}], "]"}], "\[Conjugate]"}], ".", 
           RowBox[{
            RowBox[{"BaseVectors", "[", "d2", "]"}], "[", 
            RowBox[{"[", "i", "]"}], "]"}]}]}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{"i", ",", "1", ",", "snum"}], "}"}]}], "]"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"SchmidtDecomposition", "::", "usage"}], " ", "=", " ", 
   "\"\<SchmidtDecomposition[vec,d1,d2] - Schmidt decomposition of the vector \
vec in d1\[Cross]d2-dimensional Hilbert space.\>\""}], ";"}]}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Reshaping, vectorization and reshuffling", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Vec", "[", "m_", "]"}], ":=", 
    RowBox[{"Flatten", "[", 
     RowBox[{"Transpose", "[", "m", "]"}], "]"}]}], ";"}], 
  " "}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Vec", "::", "usage"}], " ", "=", " ", 
   "\"\<Vec[m] - vectorization of the matrix m column by column. See also: \
Res.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Unvec", "[", 
    RowBox[{"v_List", ",", 
     RowBox[{"cols_:", "0"}]}], "]"}], ":=", 
   RowBox[{"Which", "[", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{
      RowBox[{"(", 
       RowBox[{"cols", "\[Equal]", " ", "0"}], ")"}], "&&", 
      RowBox[{"IntegerQ", "[", 
       RowBox[{"\[Sqrt]", 
        RowBox[{"Length", "[", "v", "]"}]}], "]"}]}], ",", 
     RowBox[{"Transpose", "[", 
      RowBox[{"Partition", "[", 
       RowBox[{"v", ",", 
        RowBox[{"\[Sqrt]", 
         RowBox[{"Length", "[", "v", "]"}]}]}], "]"}], "]"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Mod", "[", 
       RowBox[{
        RowBox[{"Length", "[", "v", "]"}], ",", "cols"}], "]"}], "\[Equal]", 
      "0"}], ",", 
     RowBox[{"Transpose", "[", 
      RowBox[{"Partition", "[", 
       RowBox[{"v", ",", "cols"}], "]"}], "]"}]}], "\[IndentingNewLine]", 
    "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Unvec", "::", "usage"}], " ", "=", " ", 
   "\"\<Unvec[v,c] - de-vectorization of the vector into the matrix with c \
colummns. If the second parameter is ommited then it is assumed that v can be \
mapped into square matrix. See also: Unres, Vec.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Res", "[", "m_List", "]"}], ":=", 
    RowBox[{"Flatten", "[", "m", "]"}]}], ";"}], " "}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Res", "::", "usage"}], " ", "=", " ", 
   "\"\<Res[m] is equvalent to Vec[m\[Transpose]]. Reshaping maps matrx m \
into vector row by row.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Unres", "[", 
    RowBox[{"v_List", ",", 
     RowBox[{"cols_:", "0"}]}], "]"}], ":=", 
   RowBox[{"Which", "[", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{
      RowBox[{"(", 
       RowBox[{"cols", "\[Equal]", " ", "0"}], ")"}], "&&", 
      RowBox[{"IntegerQ", "[", 
       RowBox[{"\[Sqrt]", 
        RowBox[{"Length", "[", "v", "]"}]}], "]"}]}], ",", 
     RowBox[{"Partition", "[", 
      RowBox[{"v", ",", 
       RowBox[{"\[Sqrt]", 
        RowBox[{"Length", "[", "v", "]"}]}]}], "]"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Mod", "[", 
       RowBox[{
        RowBox[{"Length", "[", "v", "]"}], ",", "cols"}], "]"}], "\[Equal]", 
      "0"}], ",", 
     RowBox[{"Partition", "[", 
      RowBox[{"v", ",", "cols"}], "]"}]}], "\[IndentingNewLine]", "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Unres", "::", "usage"}], " ", "=", " ", 
   "\"\<de-reshaping of the vector into the matrix with c colummns. If the \
second parameter is ommited then it is assumed that v can be mapped into \
square matrix. See also: Unvec, Res.\>\""}], ";"}]}], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(*", 
   RowBox[{
    RowBox[{
     RowBox[{"Reshuffle", "[", "m_", "]"}], ":=", 
     RowBox[{"Block", "[", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"base", "=", 
         RowBox[{"BaseMatrices", "[", 
          RowBox[{"\[Sqrt]", 
           RowBox[{"Length", "[", "m", "]"}]}], "]"}]}], "}"}], ",", 
       "\[IndentingNewLine]", 
       RowBox[{"Table", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"Res", "[", 
           RowBox[{"(", 
            RowBox[{
             RowBox[{"base", "[", 
              RowBox[{"[", "k", "]"}], "]"}], "\[CircleTimes]", 
             RowBox[{"base", "[", 
              RowBox[{"[", "l", "]"}], "]"}]}], ")"}], "]"}], ".", 
          RowBox[{"Res", "[", "m", "]"}]}], ",", 
         RowBox[{"{", 
          RowBox[{"k", ",", "1", ",", 
           RowBox[{"Length", "[", "m", "]"}]}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"l", ",", "1", ",", 
           RowBox[{"Length", "[", "m", "]"}]}], "}"}]}], "]"}]}], 
      "\[IndentingNewLine]", "]"}]}], ";"}], "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{
    RowBox[{
     RowBox[{"Reshuffle", "[", 
      RowBox[{"\[Rho]_", ",", 
       RowBox[{"m_:", "0"}], ",", 
       RowBox[{"n_:", "0"}]}], "]"}], ":=", 
     RowBox[{"Block", "[", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"base1", ",", "base2", ",", "dim"}], "}"}], ",", 
       "\[IndentingNewLine]", 
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"m", "\[Equal]", "0"}], " ", "||", " ", 
          RowBox[{"n", "\[Equal]", "0"}]}], ",", "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{"dim", "=", 
           RowBox[{"Length", "[", "\[Rho]", "]"}]}], ";", 
          RowBox[{"base1", "=", 
           RowBox[{"BaseMatrices", "[", 
            RowBox[{"Sqrt", "[", "dim", "]"}], "]"}]}], ";", 
          RowBox[{"Table", "[", 
           RowBox[{
            RowBox[{
             RowBox[{"Res", "[", 
              RowBox[{"(", 
               RowBox[{
                RowBox[{"base1", "[", 
                 RowBox[{"[", "k", "]"}], "]"}], "\[CircleTimes]", 
                RowBox[{"base1", "[", 
                 RowBox[{"[", "l", "]"}], "]"}]}], ")"}], "]"}], ".", 
             RowBox[{"Res", "[", "\[Rho]", "]"}]}], ",", 
            RowBox[{"{", 
             RowBox[{"k", ",", "1", ",", "dim"}], "}"}], ",", 
            RowBox[{"{", 
             RowBox[{"l", ",", "1", ",", "dim"}], "}"}]}], "]"}]}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{"base1", "=", 
           RowBox[{"BaseMatrices", "[", "m", "]"}]}], ";", 
          RowBox[{"base2", "=", 
           RowBox[{"BaseMatrices", "[", "n", "]"}]}], ";", 
          RowBox[{"Table", "[", 
           RowBox[{
            RowBox[{
             RowBox[{"Res", "[", 
              RowBox[{"(", 
               RowBox[{
                RowBox[{"base1", "[", 
                 RowBox[{"[", "k", "]"}], "]"}], "\[CircleTimes]", 
                RowBox[{"base2", "[", 
                 RowBox[{"[", "l", "]"}], "]"}]}], ")"}], "]"}], ".", 
             RowBox[{"Res", "[", "\[Rho]", "]"}]}], ",", 
            RowBox[{"{", 
             RowBox[{"k", ",", "1", ",", 
              RowBox[{"m", " ", "m"}]}], "}"}], ",", 
            RowBox[{"{", 
             RowBox[{"l", ",", "1", ",", 
              RowBox[{"n", " ", "n"}]}], "}"}]}], "]"}]}]}], 
        "\[IndentingNewLine]", "]"}]}], "\[IndentingNewLine]", "]"}]}], ";"}],
    "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{
     RowBox[{"Reshuffle", "::", "usage"}], " ", "=", " ", 
     "\"\<Reshuffle[\[Rho],m,n] returns representation of the \
m\[Cross]n-dimensional square matrix \[Rho] in the basis consisting of \
product matrices. If the matrix \[Rho] has dimension \!\(\*SuperscriptBox[\(d\
\), \(2\)]\) then two last arguments can be ommited. In this case one obtains \
a reshuffle in the basis contrtucted by using two bases of d-dimensional \
Hilbert-Schmidt matrix spaces.\>\""}], ";"}]}]}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Parametrizations", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Unitary2", "[", 
    RowBox[{
    "\[Alpha]_", ",", "\[Beta]_", ",", "\[Gamma]_", ",", "\[Delta]_"}], "]"}],
    ":=", 
   RowBox[{
    RowBox[{"Exp", "[", 
     RowBox[{"\[ImaginaryI]", " ", "\[Alpha]"}], "]"}], " ", 
    RowBox[{
     RowBox[{"DiagonalMatrix", "[", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"Exp", "[", 
         RowBox[{
          RowBox[{"-", " ", "\[ImaginaryI]"}], " ", 
          FractionBox["\[Beta]", "2"]}], " ", "]"}], ",", 
        RowBox[{"Exp", "[", 
         RowBox[{"\[ImaginaryI]", " ", 
          FractionBox["\[Beta]", "2"]}], " ", "]"}]}], "}"}], "]"}], ".", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{
         RowBox[{"Cos", "[", 
          FractionBox["\[Gamma]", "2"], "]"}], ",", 
         RowBox[{"-", 
          RowBox[{"Sin", "[", 
           FractionBox["\[Gamma]", "2"], "]"}]}]}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{
         RowBox[{"Sin", "[", 
          FractionBox["\[Gamma]", "2"], "]"}], ",", 
         RowBox[{"Cos", "[", 
          FractionBox["\[Gamma]", "2"], "]"}]}], "}"}]}], "}"}], ".", 
     RowBox[{"DiagonalMatrix", "[", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"Exp", "[", 
         RowBox[{
          RowBox[{"-", " ", "\[ImaginaryI]"}], " ", 
          FractionBox["\[Delta]", "2"]}], " ", "]"}], ",", 
        RowBox[{"Exp", "[", 
         RowBox[{"\[ImaginaryI]", " ", 
          FractionBox["\[Delta]", "2"]}], " ", "]"}]}], "}"}], "]"}]}]}]}], 
  ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"Unitary2", "::", "usage"}], " ", "=", " ", 
   "\"\<Euler parametrization of U(2).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"SpecialUnitary2", "[", 
    RowBox[{"\[Beta]_", ",", "\[Gamma]_", ",", "\[Delta]_"}], "]"}], ":=", 
   RowBox[{"Unitary2", "[", 
    RowBox[{"0", ",", "\[Beta]", ",", "\[Gamma]", ",", "\[Delta]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"SpecialUnitary2", "::", "usage"}], " ", "=", 
   "\"\<Euler parametrization of SU(2).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ProbablityDistribution", "[", "l_", "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"ll", ",", "N"}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"N", "=", 
       RowBox[{
        RowBox[{"Length", "[", "l", "]"}], "+", "2"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"ll", "=", 
       RowBox[{"Prepend", "[", 
        RowBox[{"l", ",", 
         RowBox[{"\[Pi]", "/", "2"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"Table", "[", 
       RowBox[{
        RowBox[{
         RowBox[{
          RowBox[{"Sin", "[", 
           RowBox[{"ll", "[", 
            RowBox[{"[", 
             RowBox[{"i", "-", "1"}], "]"}], "]"}], "]"}], "^", "2"}], "*", 
         RowBox[{"Product", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"Cos", "[", 
             RowBox[{"ll", "[", 
              RowBox[{"[", 
               RowBox[{"j", "-", "1"}], "]"}], "]"}], "]"}], "^", "2"}], ",", 
           
           RowBox[{"{", 
            RowBox[{"j", ",", 
             RowBox[{"i", "+", "1"}], ",", "N"}], "}"}]}], "]"}]}], ",", 
        RowBox[{"{", 
         RowBox[{"i", ",", "2", ",", "N"}], "}"}]}], "]"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ProbablityDistribution", "::", "usage"}], " ", "=", " ", 
   "\"\<ProbablityDistribution[{\!\(\*SubscriptBox[\(\[Theta]\), \
\(1\)]\),...,\!\(\*SubscriptBox[\(\[Theta]\), \(n\)]\)}] returns probability \
vectors of dimension n+1 parametrize with {\!\(\*SubscriptBox[\(\[Theta]\), \
\(1\)]\),...,\!\(\*SubscriptBox[\(\[Theta]\), \(n\)]\)}. See also: \
SymbolicVector.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"StateVector", "[", "l_", "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"pr", ",", "ph", ",", "N"}], "}"}], ",", "\[IndentingNewLine]", 
     
     RowBox[{
      RowBox[{"N", "=", 
       RowBox[{
        RowBox[{"Length", "[", "l", "]"}], "/", "2"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"pr", "=", 
       RowBox[{"ProbablityDistribution", "[", 
        RowBox[{"l", "[", 
         RowBox[{"[", 
          RowBox[{"1", ";;", "N"}], "]"}], "]"}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"ph", "=", 
       RowBox[{"Prepend", "[", 
        RowBox[{
         RowBox[{"Exp", "[", 
          RowBox[{"\[ImaginaryI]", "*", 
           RowBox[{"l", "[", 
            RowBox[{"[", 
             RowBox[{
              RowBox[{"N", "+", "1"}], ";;", 
              RowBox[{"2", "*", "N"}]}], "]"}], "]"}]}], "]"}], ",", "1"}], 
        "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"Sqrt", "[", "pr", "]"}], "*", "ph"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"StateVector", "::", "usage"}], " ", "=", " ", 
   "\"\<StateVector[{\!\(\*SubscriptBox[\(\[Theta]\), \
\(1\)]\),...,\!\(\*SubscriptBox[\(\[Theta]\), \(n\)]\),\!\(\*SubscriptBox[\(\
\[Phi]\), \(n + 1\)]\),...,\!\(\*SubscriptBox[\(\[Phi]\), \(2\\\ n\)]\)}] \
returns pure n+1-dimensional pure state (ket vector) constructed form \
probability distribution parametrize by numbers \
{\!\(\*SubscriptBox[\(\[Theta]\), \
\(1\)]\),...,\!\(\*SubscriptBox[\(\[Theta]\), \(n\)]\)} and phases \
{\!\(\*SubscriptBox[\(\[Phi]\), \(1\)]\),...,\!\(\*SubscriptBox[\(\[Phi]\), \
\(n\)]\)}. See also: ProbablityDistribution, SymbolicVector.\>\""}], 
  ";"}]}], "Input",
 CellChangeTimes->{{3.452405396630487*^9, 3.4524055533433104`*^9}, {
  3.4524056151576347`*^9, 3.452405771400137*^9}, {3.45240589481002*^9, 
  3.452405901538815*^9}, {3.4524059958923883`*^9, 3.452406209079464*^9}}]
}, Closed]],

Cell[CellGroupData[{

Cell["One-qubit states", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitKet", "[", 
    RowBox[{"\[Alpha]_", ",", "\[Beta]_"}], "]"}], ":=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Cos", "[", "\[Alpha]", "]"}], ",", " ", 
     RowBox[{
      RowBox[{"Exp", "[", 
       RowBox[{"\[ImaginaryI]", " ", "\[Beta]"}], "]"}], " ", 
      RowBox[{"Sin", "[", "\[Alpha]", "]"}]}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitKet", "::", "usage"}], " ", "=", " ", 
   "\"\<QubitKet[\[Alpha],\[Beta]] parametriation of the pure state (as a \
state vector) for one qubit as (cos(\[Alpha]) \!\(\*SuperscriptBox[\(\
\[ExponentialE]\), \(\[ImaginaryI]\[Beta]\)]\), sin(\[Alpha])). This is \
equivalent to StateVector[{\[Alpha],\[Beta]}]. See also: QubitPureState, \
StateVector.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitPureState", "[", 
    RowBox[{"\[Alpha]_", ",", "\[Beta]_"}], "]"}], ":=", 
   RowBox[{"Proj", "[", 
    RowBox[{"QubitKet", "[", 
     RowBox[{"\[Alpha]", ",", "\[Beta]"}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitPureState", "::", "usage"}], " ", "=", " ", 
   "\"\<QubitPureState[\[Alpha],\[Beta]] - parametriation of the pure state \
as a density matrix for one qubit. This is just a alias for Proj[QubitKet[\
\[Alpha],\[Beta]]]. See also: QubitKet.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitBlochState", "[", 
    RowBox[{"a_", ",", "b_", ",", "c_"}], "]"}], ":=", 
   RowBox[{
    RowBox[{
     RowBox[{"1", "/", "2"}], "id"}], " ", "+", " ", 
    RowBox[{"a", " ", "sx"}], " ", "+", " ", 
    RowBox[{"b", " ", "sy"}], " ", "+", " ", 
    RowBox[{"c", " ", "sz"}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitBlochState", "::", "usage"}], " ", "=", " ", 
   "\"\<Parametrization of the one-qubit mixed state on the Bloch \
sphere.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitState", "[", 
    RowBox[{
    "\[Alpha]_", ",", "\[Beta]_", ",", "\[Gamma]_", ",", "\[Delta]_", ",", 
     "\[Lambda]_"}], "]"}], ":=", 
   RowBox[{
    RowBox[{"Unitary2", "[", 
     RowBox[{"\[Alpha]", ",", "\[Beta]", ",", "\[Gamma]", ",", "\[Delta]"}], 
     "]"}], ".", 
    RowBox[{"DiagonalMatrix", "[", 
     RowBox[{"{", 
      RowBox[{"\[Lambda]", ",", 
       RowBox[{"1", "-", "\[Lambda]"}]}], "}"}], "]"}], ".", 
    RowBox[{
     RowBox[{"Unitary2", "[", 
      RowBox[{"\[Alpha]", ",", "\[Beta]", ",", "\[Gamma]", ",", "\[Delta]"}], 
      "]"}], "\[ConjugateTranspose]"}]}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitState", "::", "usage"}], " ", "=", " ", 
   "\"\<QubitState[\[Alpha],\[Beta],\[Gamma],\[Delta],\[Lambda]] - \
Parametrization of the one-qubit mixed state using rotations and eigenvalues. \
Returns one-qubits density matrix with eigenvalues \[Lambda] and 1-\[Lambda] \
rotated as U.diag(\[Lambda],1-\[Lambda]).\!\(\*SuperscriptBox[\(U\), \(\
\[Dagger]\)]\) with U defined by parameters \[Alpha],\[Beta],\[Gamma] and \
\[Delta].\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitGeneralState", " ", "[", 
    RowBox[{"a_", ",", "b_"}], "]"}], ":=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"a", ",", 
       RowBox[{"Conjugate", "[", "b", "]"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"b", ",", 
       RowBox[{"1", "-", "a"}]}], "}"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitGeneralState", "::", "usage"}], " ", "=", " ", 
   "\"\<Parametrization of the one-qubits mixed state using only \
normalization and self-adjointness.\>\""}], ";"}]}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Quantum channels", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"IdentityChannel", "=", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", ",", "\[Rho]"}], "}"}], ",", 
     RowBox[{
      RowBox[{"IdentityMatrix", "[", "dim", "]"}], ".", "\[Rho]"}]}], "]"}]}],
   ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"IdentityChannel", "::", "usage"}], "=", 
   "\"\<IdentityChannel[n, \[Rho]] - applay identity operation on \
n-dimensional density matrix \[Rho].\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"TransposeChannel", "=", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", ",", "\[Rho]"}], "}"}], ",", 
     RowBox[{
      RowBox[{"IdentityMatrix", "[", "dim", "]"}], ".", 
      RowBox[{"\[Rho]", "\[Transpose]"}]}]}], "]"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"TransposeChannel", "::", "usage"}], "=", 
   "\"\<TransposeChannel[n, \[Rho]] - applay transposition operation on \
n-dimensional density matrix \[Rho]. This operations is not completely \
positive.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"DepolarizingChannel", "=", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", ",", "p", ",", "\[Rho]"}], "}"}], ",", 
     RowBox[{
      RowBox[{"p", " ", 
       RowBox[{
        RowBox[{"IdentityMatrix", "[", "dim", "]"}], ".", "\[Rho]"}]}], "+", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"1", "-", "p"}], ")"}], " ", 
       RowBox[{"Tr", "[", "\[Rho]", "]"}], 
       RowBox[{"MaxMix", "[", "dim", "]"}]}]}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"DepolarizingChannel", "::", "usage"}], " ", "=", " ", 
   "\"\<DepolarizingChannel[n,p,\[Rho]] performs an action of the completely \
depolarizing channel with paramaeter p acting on n-dimensional input state \
\[Rho]. See also: QubitDepolarizingKraus, HolevoWernerChannel.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"BitflipChannel", "=", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", ",", "p", ",", "\[Rho]"}], "}"}], ",", 
     RowBox[{
      RowBox[{"p", " ", 
       RowBox[{
        RowBox[{"IdentityMatrix", "[", "dim", "]"}], ".", "\[Rho]"}]}], "+", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"1", "-", "p"}], ")"}], 
       RowBox[{"sx", ".", "\[Rho]", ".", 
        RowBox[{"sx", "\[ConjugateTranspose]"}]}]}]}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"BitflipChannel", "::", "usage"}], "  ", "=", " ", 
   "\"\<BitflipChannel[2,p,\[Rho]] - \!\(\*
StyleBox[\"bit\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"-\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"flip\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"channel\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"for\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"one\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"qubit\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"as\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"a\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"pure\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"function\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\".\",
FontWeight->\"Plain\"]\)\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"PhaseflipChannel", "=", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", ",", "p", ",", "\[Rho]"}], "}"}], ",", 
     RowBox[{
      RowBox[{"p", " ", 
       RowBox[{
        RowBox[{"IdentityMatrix", "[", "dim", "]"}], ".", "\[Rho]"}]}], "+", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"1", "-", "p"}], ")"}], 
       RowBox[{"sz", ".", "\[Rho]", ".", 
        RowBox[{"sz", "\[ConjugateTranspose]"}]}]}]}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"PhaseflipChannel", "::", "usage"}], "  ", "=", " ", 
   "\"\<PhaseflipChannel[2,p,\[Rho]] - \!\(\*
StyleBox[\"phase\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"-\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"flip\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"channel\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"for\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"one\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"qubit\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"as\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"a\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"pure\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"function\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\".\",
FontWeight->\"Plain\"]\)\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"BitphaseflipChannel", "=", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", ",", "p", ",", "\[Rho]"}], "}"}], ",", 
     RowBox[{
      RowBox[{"p", " ", 
       RowBox[{
        RowBox[{"IdentityMatrix", "[", "dim", "]"}], ".", "\[Rho]"}]}], "+", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"1", "-", "p"}], ")"}], 
       RowBox[{"sy", ".", "\[Rho]", ".", 
        RowBox[{"sy", "\[ConjugateTranspose]"}]}]}]}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"BitphaseflipChannel", "::", "usage"}], "  ", "=", " ", 
   "\"\<BitphaseflipChannel[2,p,\[Rho]] - bit-\!\(\*
StyleBox[\"phase\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"-\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"flip\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"channel\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"for\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"one\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"qubit\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"as\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"a\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"pure\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\"function\",
FontWeight->\"Plain\"]\)\!\(\*
StyleBox[\".\",
FontWeight->\"Plain\"]\)\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"HolevoWernerChannel", "=", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"dim", ",", "p", ",", "\[Rho]"}], "}"}], ",", 
     RowBox[{
      FractionBox["1", 
       RowBox[{"dim", "-", "1"}]], 
      RowBox[{"(", " ", 
       RowBox[{
        RowBox[{"p", " ", 
         RowBox[{"\[Rho]", "\[Transpose]"}]}], "+", " ", 
        RowBox[{
         RowBox[{"(", 
          RowBox[{"1", "-", "p"}], ")"}], 
         RowBox[{"Tr", "[", "\[Rho]", "]"}], 
         RowBox[{"MaxMix", "[", "dim", "]"}]}]}], ")"}]}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"HolevoWernerChannel", "::", "usage"}], " ", "=", " ", 
   "\"\<HolevoWernerChannel[n,p,\[Rho]] performs an action of the \
Holeve-Werner channel (also known as transpose depolarizing channel) with \
paramaeter p acting on n-dimensional input state \[Rho]. See also: \
DepolarizingChannel.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ChannelToMatrix", "[", 
    RowBox[{"fun_", ",", "dim_"}], "]"}], ":=", "\[IndentingNewLine]", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"Tr", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"(", 
         RowBox[{"fun", "[", 
          RowBox[{
           RowBox[{"BaseMatrices", "[", "dim", "]"}], "[", 
           RowBox[{"[", "i", "]"}], "]"}], "]"}], ")"}], 
        "\[ConjugateTranspose]"}], ".", 
       RowBox[{
        RowBox[{"BaseMatrices", "[", "dim", "]"}], "[", 
        RowBox[{"[", "j", "]"}], "]"}]}], "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", 
       RowBox[{"dim", "^", "2"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", 
       RowBox[{"dim", "^", "2"}]}], "}"}]}], "]"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"ChannelToMatrix", "::", "usage"}], " ", "=", " ", 
   "\"\<ChannelToMatrix[E,d] returns matrix representation of a channel E \
acting on d-dimensional state space \!\(\*
StyleBox[\"i\",
FontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",
FontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"e\",
FontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",
FontSlant->\"Italic\"]\) matrix \!\(\*SubscriptBox[\(M\), \(E\)]\) such that \
\!\(\*SubscriptBox[\(M\), \(E\)]\) res(\[Rho])=\!\(\*SuperscriptBox[\(res\), \
\(-1\)]\)(E(\[Rho])). Here res(M) is a reshaping of matrix M implemented by \
Res[M] and \!\(\*SuperscriptBox[\(res\), \(-1\)]\)(M) is implemented as \
Unres[M]. First argument should be a pure function E such that E[\[Rho]] \
transforms input state according to the channel definition. For example for \
the Holevo-Werner channel one ca use \
ChannelToMatrix[HolevoWernerChannel[3,p,#]&,3] to obtain matrix \
representation of this channel acting on qutrits. See also: \
Superoperator.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ApplyKraus", "[", 
    RowBox[{"ch_", ",", "\[Rho]_"}], "]"}], ":=", 
   RowBox[{"Sum", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"ch", "[", 
       RowBox[{"[", "k", "]"}], "]"}], ".", "\[Rho]", ".", 
      RowBox[{"(", 
       RowBox[{
        RowBox[{"ch", "[", 
         RowBox[{"[", "k", "]"}], "]"}], "\[ConjugateTranspose]"}], ")"}]}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"k", ",", "1", ",", 
       RowBox[{"Length", "[", "ch", "]"}]}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ApplyKraus", "::", "usage"}], " ", "=", " ", 
   "\"\<ApplyKraus[ch,\[Rho]] - applay channel ch, given as a list of Kraus \
operators, to the input state \[Rho].\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Superoperator", "[", "ch_List", "]"}], ":=", 
   RowBox[{"Sum", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"ch", "[", 
       RowBox[{"[", "i", "]"}], "]"}], "\[CircleTimes]", 
      RowBox[{
       RowBox[{"ch", "[", 
        RowBox[{"[", "i", "]"}], "]"}], "\[Conjugate]"}]}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", 
       RowBox[{"Length", "[", "ch", "]"}]}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Superoperator", "[", 
    RowBox[{"fun_Function", ",", "dim_Integer"}], "]"}], ":=", 
   RowBox[{"ChannelToMatrix", "[", 
    RowBox[{"fun", ",", "dim"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Superoperator", "::", "usage"}], " ", "=", " ", 
   "\"\<Superoperator[kl] returns matrix representation of quantum channel \
given as a list of Kraus operators. Superoperator[fun,dim] is just am \
alternative name for ChannelToMatrix[fun,dim] and returns matrix \
representation of quantum channel, given as a pure function, acting on \
dim-deimensionla space. So Superoperator[DepolarizingChannel[2,p,#]&,2] and \
Superoperator[QubitDepolarizingKraus[p]] returns the same matrix. See also: \
ChannelToMatrix.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"DynamicalMatrix", "[", "ch_List", "]"}], ":=", 
   RowBox[{"Reshuffle", "[", 
    RowBox[{"Superoperator", "[", "ch", "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"DynamicalMatrix", "[", 
    RowBox[{"fun_Function", ",", "dim_Integer"}], "]"}], ":=", 
   RowBox[{"Reshuffle", "[", 
    RowBox[{"Superoperator", "[", 
     RowBox[{"fun", ",", "dim"}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"DynamicalMatrix", "::", "usage"}], " ", "=", " ", 
   "\"\<Dynamical matrix of quantum channel given as a list of Kraus \
operators (DynamicalMatrix[ch]) or as a function fun action on \
dim-dimensional space (DynamicalMatrix[fun,dim]). See alos: Superoperator, \
ChannelToMatrix.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Jamiolkowski", "[", "ch_List", "]"}], ":=", 
   RowBox[{
    FractionBox["1", 
     RowBox[{"Length", "[", 
      RowBox[{"ch", "[", 
       RowBox[{"[", "1", "]"}], "]"}], "]"}]], 
    RowBox[{"DynamicalMatrix", "[", "ch", "]"}]}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"Jamiolkowski", "[", 
    RowBox[{"fun_Function", ",", "dim_Integer"}], "]"}], ":=", 
   RowBox[{
    FractionBox["1", "dim"], 
    RowBox[{"DynamicalMatrix", "[", 
     RowBox[{"fun", ",", "dim"}], "]"}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Jamiolkowski", "::", "usage"}], " ", "=", " ", 
   "\"\<Jamiolkowski[K] gives the image of the Jamiolkowski isomorfizm for \
the channel given as the list of Karus operators K. Jamiolkowski[fun,dim] \
gives the image of the Jamiolkowski isomorfizm for the channel given as a \
function fun action on dim-dimensional space. See alos: Superoperator, \
ChannelToMatrix, DynamicalMatrix.\>\""}], ";"}]}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Partial trace and transposition", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"PartialTransposeA", "[", 
    RowBox[{"\[Rho]_", ",", "m_", ",", "n_"}], "]"}], ":=", 
   RowBox[{"Reshuffle", "[", 
    RowBox[{"Unres", "[", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{
        RowBox[{"Swap", "[", "m", "]"}], "\[CircleTimes]", 
        RowBox[{"IdentityMatrix", "[", 
         RowBox[{"n", " ", "n"}], "]"}]}], ")"}], ".", 
      RowBox[{"Res", "[", 
       RowBox[{"Reshuffle", "[", "\[Rho]", "]"}], "]"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"PartialTransposeA", "::", "usage"}], " ", "=", " ", 
   "\"\<PartialTransposeA[\[Rho],m,n] performs partial transposition on the \
m-dimensional (first) subsystem of the m\[Cross]n-state.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"PartialTransposeB", "[", 
    RowBox[{"\[Rho]_", ",", "m_", ",", "n_"}], "]"}], ":=", 
   RowBox[{"Reshuffle", "[", 
    RowBox[{"Unres", "[", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{
        RowBox[{"IdentityMatrix", "[", 
         RowBox[{"m", " ", "m"}], "]"}], "\[CircleTimes]", 
        RowBox[{"Swap", "[", "n", "]"}]}], ")"}], ".", 
      RowBox[{"Res", "[", 
       RowBox[{"Reshuffle", "[", "\[Rho]", "]"}], "]"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"PartialTransposeB", "::", "usage"}], " ", "=", " ", 
   "\"\<PartialTransposeB[\[Rho],m,n] performs partial transposition on the \
n-dimensional (second) subsystem of the m\[Cross]n-state.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"PartialTraceA", "[", 
    RowBox[{"\[Rho]_", ",", "m_", ",", "n_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", "trMtx", "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"trMtx", "=", 
       RowBox[{"ChannelToMatrix", "[", 
        RowBox[{
         RowBox[{
          RowBox[{
           RowBox[{"IdentityMatrix", "[", "m", "]"}], 
           RowBox[{"Tr", "[", "#", "]"}]}], "&"}], ",", "m"}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"Unres", "[", 
       RowBox[{
        RowBox[{"(", 
         RowBox[{
          RowBox[{"(", 
           RowBox[{"trMtx", "\[CircleTimes]", 
            RowBox[{"IdentityMatrix", "[", 
             RowBox[{"n", " ", "n"}], "]"}]}], ")"}], ".", 
          RowBox[{"Res", "[", 
           RowBox[{"Reshuffle", "[", 
            RowBox[{"\[Rho]", ",", "m", ",", "n"}], "]"}], "]"}]}], ")"}], 
        "[", 
        RowBox[{"[", 
         RowBox[{"1", ";;", 
          RowBox[{"n", " ", "n"}]}], "]"}], "]"}], "]"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"PartialTraceA", "::", "usage"}], " ", "=", " ", 
   "\"\<PartialTraceA[\[Rho],m,n] performs partial trace on \
m\[Cross]n-dimensional density matrix \[Rho] with respect to the \
m-demensional (first) subsystem.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"PartialTraceB", "[", 
    RowBox[{"\[Rho]_", ",", "m_", ",", "n_"}], "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", "trMtx", "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"trMtx", "=", 
       RowBox[{"ChannelToMatrix", "[", 
        RowBox[{
         RowBox[{
          RowBox[{
           RowBox[{"IdentityMatrix", "[", "n", "]"}], 
           RowBox[{"Tr", "[", "#", "]"}]}], "&"}], ",", "n"}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"Unres", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"Unres", "[", 
          RowBox[{
           RowBox[{"(", 
            RowBox[{
             RowBox[{"IdentityMatrix", "[", 
              RowBox[{"m", " ", "m"}], "]"}], "\[CircleTimes]", "trMtx"}], 
            ")"}], ".", 
           RowBox[{"Res", "[", 
            RowBox[{"Reshuffle", "[", 
             RowBox[{"\[Rho]", ",", "m", ",", "n"}], "]"}], "]"}]}], "]"}], 
         "\[Transpose]"}], "[", 
        RowBox[{"[", "1", "]"}], "]"}], "]"}]}]}], "\[IndentingNewLine]", 
    "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"PartialTraceB", "::", "usage"}], " ", "=", " ", 
   "\"\<PartialTraceB[\[Rho],m,n] performs partial trace on \
m\[Cross]n-dimensional density matrix \[Rho] with respect to the \
n-demensional (second) subsystem.\>\""}], ";"}]}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["One-qubit quantum channels", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitDepolarizingKraus", "[", "p_", "]"}], ":=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        FractionBox[
         RowBox[{
          RowBox[{"3", " ", "p"}], " ", "+", "1"}], "4"], ")"}]}], "id"}], 
     ",", 
     RowBox[{
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        FractionBox[
         RowBox[{"1", "-", "p"}], "4"], ")"}]}], "sx"}], ",", 
     RowBox[{
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        FractionBox[
         RowBox[{"1", "-", "p"}], "4"], ")"}]}], "sy"}], ",", 
     RowBox[{
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        FractionBox[
         RowBox[{"1", "-", "p"}], "4"], ")"}]}], "sz"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitDepolarizingKraus", "::", "usage"}], " ", "=", " ", 
   "\"\<Kraus operators of the depolarizing channel for one qubit. Note that \
it gives maximally mixed state for p=0.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitDecayKraus", "[", "p_", "]"}], ":=", 
   RowBox[{"{", " ", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "0"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"0", ",", 
         RowBox[{"\[Sqrt]", "p"}]}], "}"}]}], "}"}], " ", ",", " ", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"0", ",", 
         RowBox[{"\[Sqrt]", 
          RowBox[{"(", 
           RowBox[{"1", "-", "p"}], ")"}]}]}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"0", ",", "0"}], "}"}]}], "}"}]}], " ", "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitDecayKraus", "::", "usage"}], " ", "=", " ", 
   "\"\<Kraus operators of the decay channel, also know as amplitude damping, \
for one qubit.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitPhaseKraus", "[", "p_", "]"}], ":=", 
   RowBox[{"{", " ", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "0"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"0", ",", 
         RowBox[{"\[Sqrt]", 
          RowBox[{"(", 
           RowBox[{"1", "-", "p"}], ")"}]}]}], "}"}]}], "}"}], " ", ",", " ", 
     
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"0", ",", "0"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"0", ",", 
         RowBox[{"\[Sqrt]", "p"}]}], "}"}]}], "}"}]}], " ", "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitPhaseKraus", "::", "usage"}], " ", "=", " ", 
   "\"\<Kraus operators for one qubit phase damping channel.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitBitflipKraus", "[", "p_", "]"}], ":=", 
   RowBox[{"{", " ", 
    RowBox[{
     RowBox[{
      RowBox[{"\[Sqrt]", "p"}], " ", "id"}], ",", 
     RowBox[{
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        RowBox[{"1", "-", "p"}], ")"}]}], " ", "sx"}]}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitBitflipKraus", "::", "usage"}], " ", "=", " ", 
   "\"\<Kraus operators for one qubit bit-flip channel.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitPhaseflipKraus", "[", "p_", "]"}], ":=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{"\[Sqrt]", "p"}], " ", "id"}], ",", 
     RowBox[{
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        RowBox[{"1", "-", "p"}], ")"}]}], " ", "sz"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitPhaseflipKraus", "::", "usage"}], " ", "=", " ", 
   "\"\<Kraus operators for one qubit phase-flip channel.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QubitBitphaseflipKraus", "[", "p_", "]"}], ":=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{"\[Sqrt]", "p"}], " ", "id"}], ",", 
     RowBox[{
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        RowBox[{"1", "-", "p"}], ")"}]}], " ", "sy"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QubitBitphaseflipKraus", "::", "usage"}], " ", "=", " ", 
   "\"\<Kraus operators for one qubit bit-phase-flip channel.\>\""}], 
  ";"}]}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Entropies", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Log0", "[", "x_", "]"}], ":=", 
   RowBox[{"If", "[", 
    RowBox[{
     RowBox[{"x", "\[Equal]", "0"}], ",", "0", ",", 
     RowBox[{"Log", "[", 
      RowBox[{"2", ",", "x"}], "]"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"Log0", ",", "Listable"}], "]"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"Log0", "::", "usage"}], " ", "=", " ", 
   "\"\<Log0[x] is equal to Log[2,x] for x>0 and 1 for x=0.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"\[Eta]", "[", "x_", "]"}], ":=", " ", 
   RowBox[{
    RowBox[{"-", "x"}], " ", 
    RowBox[{"Log", "[", "x", "]"}]}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"\[Eta]", ",", "Protected"}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Eta]", "::", "usage"}], " ", "=", " ", 
   "\"\<\[Eta][x] = -x Log[2,x]\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"\[Eta]2", "[", "x_", "]"}], ":=", " ", 
   RowBox[{
    RowBox[{
     RowBox[{"-", "x"}], " ", 
     RowBox[{"Log", "[", "x", "]"}]}], " ", "-", " ", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{"1", "-", "x"}], ")"}], 
     RowBox[{"Log", "[", 
      RowBox[{"2", ",", 
       RowBox[{"1", "-", "x"}]}], "]"}]}]}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Eta]2", "::", "usage"}], " ", "=", " ", 
   "\"\<\[Eta]2[x] = \[Eta][x]+\[Eta][1-x]\>\""}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"\[Eta]2", ",", "Protected"}], "]"}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QuantumEntropy", "[", "m_", "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"eigvals", ",", "qe"}], "}"}], ",", 
     RowBox[{
      RowBox[{"eigvals", "=", 
       RowBox[{"Chop", "[", 
        RowBox[{"Eigenvalues", "[", "m", "]"}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"qe", "=", 
       RowBox[{"Sum", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"eigvals", "[", 
           RowBox[{"[", "i", "]"}], "]"}], " ", 
          RowBox[{"Log0", "[", 
           RowBox[{"eigvals", "[", 
            RowBox[{"[", "i", "]"}], "]"}], "]"}]}], ",", 
         RowBox[{"{", 
          RowBox[{"i", ",", "1", ",", 
           RowBox[{"Length", "[", "eigvals", "]"}]}], "}"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"-", " ", 
       RowBox[{"Chop", "[", "qe", "]"}]}]}]}], "\[IndentingNewLine]", "]"}]}],
   ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QuantumEntropy", "::", "usage"}], " ", "=", " ", 
   "\"\<QuantumEntropy[m] - von Neuman entropy for the matrix m.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"S", "[", "m_", "]"}], ":=", 
   RowBox[{"QuantumEntropy", "[", "m", "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"S", ",", "Protected"}], "]"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"S", "::", "usage"}], " ", "=", " ", 
   "\"\<S[m] = QuantumEntropy[m]\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"QuantumChannelEntropy", "[", "ch_List", "]"}], ":=", 
   RowBox[{"QuantumEntropy", "[", 
    RowBox[{"Jamiolkowski", "[", "ch", "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QuantumChannelEntropy", "[", 
    RowBox[{"fun_Function", ",", "dim_Integer"}], "]"}], ":=", 
   RowBox[{"QuantumEntropy", "[", 
    RowBox[{"Jamiolkowski", "[", 
     RowBox[{"fun", ",", "dim"}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"QuantumChannelEntropy", "::", "usage"}], " ", "=", " ", 
   "\"\<QuantumChannelEntropy[ch] - von Neuman entropy of the quantum channel \
calculated as a von Neuman entropy for the image of this channe in \
Jamiolkowski isomorphism. See also: Jamiolkowski, Superoperator.\>\""}], 
  ";"}]}], "Input"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Distribution of eigenvalues", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"\[Delta]", "[", 
     RowBox[{"a_", ",", 
      RowBox[{"type_:", "\"\<Dirac\>\""}]}], "]"}], "=", 
    RowBox[{"Switch", "[", 
     RowBox[{"type", ",", "\[IndentingNewLine]", "\"\<Dirac\>\"", ",", 
      RowBox[{"DiracDelta", "[", "a", "]"}], ",", "\[IndentingNewLine]", 
      "\"\<Indicator\>\"", ",", 
      RowBox[{"DiscreteDelta", "[", "a", "]"}]}], "]"}]}], ";"}], 
  " "}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"\[Delta]", "::", "usage"}], " ", "=", " ", 
   "\"\<\[Delta][x] represents Dirac delta at x. \
\[Delta][x,\\\"Indicator\\\"] is equal to 1 at x and zero elsewhere.\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"VandermondeMatrix", "[", "l_", "]"}], ":=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"Table", "[", 
      RowBox[{
       SuperscriptBox[
        RowBox[{"l", "[", 
         RowBox[{"[", "j", "]"}], "]"}], "i"], ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", "0", ",", 
         RowBox[{
          RowBox[{"Length", "[", "l", "]"}], "-", "1"}]}], "}"}]}], "]"}], 
     ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", 
       RowBox[{"Length", "[", "l", "]"}]}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"VandermondeMatrix", "::", "usage"}], " ", "=", " ", 
   "\"\<VandermondeMatrix[{\!\(\*SubscriptBox[\(x\), \
\(1\)]\),...\!\(\*SubscriptBox[\(x\), \(n\)]\)}] - Vandermonde matrix for \
variables (\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \
\(n\)]\)).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ProdSum", "[", "l_", "]"}], ":=", 
   RowBox[{"Times", "@@", 
    RowBox[{"Flatten", "[", 
     RowBox[{"Table", "[", 
      RowBox[{
       RowBox[{"Table", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"l", "[", 
           RowBox[{"[", "i", "]"}], "]"}], "+", 
          RowBox[{"l", "[", 
           RowBox[{"[", "j", "]"}], "]"}]}], ",", 
         RowBox[{"{", 
          RowBox[{"i", ",", "1", ",", 
           RowBox[{"j", "-", "1"}]}], "}"}]}], "]"}], ",", 
       RowBox[{"{", 
        RowBox[{"j", ",", "2", ",", 
         RowBox[{"Length", "[", "l", "]"}]}], "}"}]}], "]"}], "]"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ProdSum", "::", "usage"}], " ", "=", " ", 
   "\"\<ProdSum[{\!\(\*SubscriptBox[\(x\), \
\(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}] gives \
\!\(\*SubsuperscriptBox[\(\[Product]\), \(i < j\), \
\(n\)]\)(\!\(\*SubscriptBox[\(x\), \(i\)]\)+\!\(\*SubscriptBox[\(x\), \
\(j\)]\)).\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ProdDiff2", "[", "l_", "]"}], ":=", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", "x", "}"}], ",", 
     RowBox[{"Discriminant", "[", 
      RowBox[{
       RowBox[{"Times", "@@", 
        RowBox[{"Table", "[", 
         RowBox[{
          RowBox[{"(", 
           RowBox[{"x", "-", 
            RowBox[{"l", "[", 
             RowBox[{"[", "i", "]"}], "]"}]}], ")"}], ",", 
          RowBox[{"{", 
           RowBox[{"i", ",", "1", ",", 
            RowBox[{"Length", "[", "l", "]"}]}], "}"}]}], "]"}]}], ",", "x"}],
       "]"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ProdDiff2", "::", "usage"}], " ", "=", " ", 
   "\"\<ProdDiff2[{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\
\(x\), \(n\)]\)}] is equivalent to Det[VandermondeMatrix[{\!\(\*SubscriptBox[\
\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}]\!\(\*SuperscriptBox[\
\(]\), \(2\)]\) and gives a discriminant of the polynomial with roots \
{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \
\(n\)]\)}.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ProbBuresNorm", "[", "N_", "]"}], ":=", 
   RowBox[{
    SuperscriptBox["2", 
     RowBox[{
      SuperscriptBox["N", "2"], "-", "N"}]], 
    FractionBox[
     RowBox[{"Gamma", "[", 
      RowBox[{
       SuperscriptBox["N", "2"], "/", "2"}], "]"}], 
     RowBox[{
      SuperscriptBox["\[Pi]", 
       RowBox[{"N", "/", "2"}]], 
      RowBox[{"Product", "[", 
       RowBox[{
        RowBox[{"Gamma", "[", 
         RowBox[{"j", "+", "1"}], "]"}], ",", 
        RowBox[{"{", 
         RowBox[{"j", ",", "1", ",", "N"}], "}"}]}], "]"}]}]]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ProbBuresNorm", "::", "usage"}], " ", "=", " ", 
   "\"\<ProbBNorm[n] - Normalization factor used for calculating probablity \
distribution of eigenvalues of matrix of dimension N according to Bures \
distance.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ProbBures", "[", 
    RowBox[{"l_", ",", 
     RowBox[{"delta_:", "\"\<Dirac\>\""}]}], "]"}], ":=", 
   RowBox[{"FullSimplify", "[", 
    RowBox[{
     RowBox[{"ProbBuresNorm", "[", 
      RowBox[{"Length", "[", "l", "]"}], "]"}], 
     FractionBox[
      RowBox[{"\[Delta]", "[", 
       RowBox[{
        RowBox[{
         RowBox[{
          SubsuperscriptBox["\[Sum]", 
           RowBox[{"i", "=", "1"}], 
           RowBox[{"Length", "[", "l", "]"}]], 
          RowBox[{"l", "[", 
           RowBox[{"[", "i", "]"}], "]"}]}], "-", "1"}], ",", "delta"}], 
       "]"}], 
      RowBox[{"\[Sqrt]", 
       RowBox[{"(", 
        RowBox[{
         SubsuperscriptBox["\[Product]", 
          RowBox[{"i", "=", "1"}], 
          RowBox[{"Length", "[", "l", "]"}]], 
         RowBox[{"l", "[", 
          RowBox[{"[", "i", "]"}], "]"}]}], ")"}]}]], 
     FractionBox[
      SuperscriptBox[
       RowBox[{"Det", "[", 
        RowBox[{"VandermondeMatrix", "[", "l", "]"}], "]"}], "2"], 
      RowBox[{"ProdSum", "[", "l", "]"}]]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ProbBures", "::", "usage"}], " ", "=", " ", 
   "\"\<ProbBures[\[Lambda]] - Joint probablity distribution of eigenvalues \
\[Lambda] of a matrix according to Bures distance. By default \[Delta] is \
assumed to be Dirac delta. Other possible values: \\\"Indicator\\\"\>\""}], 
  ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ProbHSNorm", "[", "N_", "]"}], ":=", 
   FractionBox[
    RowBox[{"Gamma", "[", 
     SuperscriptBox["N", "2"], "]"}], 
    RowBox[{"Product", "[", 
     RowBox[{
      RowBox[{
       RowBox[{"Gamma", "[", 
        RowBox[{"N", "-", "j"}], "]"}], " ", 
       RowBox[{"Gamma", "[", 
        RowBox[{"N", "-", "j", "+", "1"}], "]"}]}], ",", 
      RowBox[{"{", 
       RowBox[{"j", ",", "0", ",", 
        RowBox[{"N", "-", "1"}]}], "}"}]}], "]"}]]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ProbHSNorm", "::", "usage"}], " ", "=", " ", 
   "\"\<Normalization factor used for calculating probablity distribution of \
eigenvalues of matrix of dimension N according to Hilbert-Schmidt \
distribution.\>\""}], ";"}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ProbHS", "[", 
    RowBox[{"l_", ",", 
     RowBox[{"delta_:", "\"\<Dirac\>\""}]}], "]"}], ":=", 
   RowBox[{
    RowBox[{"ProbHSNorm", "[", 
     RowBox[{"Length", "[", "l", "]"}], "]"}], 
    RowBox[{"\[Delta]", "[", 
     RowBox[{
      RowBox[{"1", "-", 
       RowBox[{"(", 
        RowBox[{"Plus", "@@", "l"}], ")"}]}], ",", "delta"}], "]"}], 
    SuperscriptBox[
     RowBox[{"Det", "[", 
      RowBox[{"VandermondeMatrix", "[", "l", "]"}], "]"}], "2"]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ProbHS", "::", "usage"}], " ", "=", " ", 
   "\"\<ProbHS[{\!\(\*SubscriptBox[\(x\), \
\(1\)]\),...\!\(\*SubscriptBox[\(x\), \(n\)]\)},] Probablity distribution of \
eigenvalues of matrix according to Hilbert-Schmidt distance. By default \
\[Delta] is assumed to be Dirac delta. Other possible values: \\\"Indicator\\\
\"\>\""}], ";"}]}], "Input"]
}, Open  ]]
}, Open  ]]
},
WindowSize->{1270, 963},
WindowMargins->{{0, Automatic}, {Automatic, 0}},
ShowSelection->True,
TrackCellChangeTimes->False,
FrontEndVersion->"7.0 for Linux x86 (64-bit) (February 25, 2009)",
StyleDefinitions->"Default.nb"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{}
*)
(*CellTagsIndex
CellTagsIndex->{}
*)
(*NotebookFileOutline
Notebook[{
Cell[CellGroupData[{
Cell[567, 22, 54, 0, 84, "Title"],
Cell[CellGroupData[{
Cell[646, 26, 61, 0, 73, "Section"],
Cell[710, 28, 438, 13, 55, "Input"],
Cell[1151, 43, 1320, 35, 165, "Input"],
Cell[2474, 80, 1650, 42, 231, "Input"],
Cell[4127, 124, 585, 14, 99, "Input"],
Cell[4715, 140, 508, 13, 77, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[5260, 158, 48, 0, 43, "Section"],
Cell[5311, 160, 366, 10, 55, "Input"],
Cell[5680, 172, 412, 11, 55, "Input"],
Cell[6095, 185, 785, 21, 55, "Input"],
Cell[6883, 208, 1192, 31, 86, "Input"],
Cell[8078, 241, 1354, 33, 70, "Input"],
Cell[9435, 276, 600, 16, 55, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[10072, 297, 41, 0, 73, "Section"],
Cell[10116, 299, 2744, 85, 363, "Input"],
Cell[12863, 386, 4285, 131, 363, "Input"],
Cell[17151, 519, 753, 23, 55, "Input"],
Cell[17907, 544, 537, 16, 55, "Input"],
Cell[18447, 562, 650, 19, 55, "Input"],
Cell[19100, 583, 928, 24, 121, "Input"],
Cell[20031, 609, 1282, 32, 77, "Input"],
Cell[21316, 643, 1396, 35, 55, "Input"],
Cell[22715, 680, 1232, 35, 113, "Input"],
Cell[23950, 717, 2102, 54, 231, "Input"],
Cell[26055, 773, 432, 12, 55, "Input"],
Cell[26490, 787, 379, 10, 55, "Input"],
Cell[26872, 799, 535, 12, 55, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[27444, 816, 32, 0, 43, "Section"],
Cell[27479, 818, 1246, 31, 105, "Input"],
Cell[28728, 851, 1567, 39, 188, "Input"],
Cell[30298, 892, 627, 18, 55, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[30962, 915, 34, 0, 43, "Section"],
Cell[30999, 917, 970, 26, 187, "Input"],
Cell[31972, 945, 602, 17, 55, "Input"],
Cell[32577, 964, 398, 12, 69, "Input"],
Cell[32978, 978, 1391, 35, 153, "Input"],
Cell[34372, 1015, 1974, 52, 165, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[36383, 1072, 40, 0, 43, "Section"],
Cell[36426, 1074, 2781, 74, 187, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[39244, 1153, 59, 0, 43, "Section"],
Cell[39306, 1155, 393, 12, 55, "Input"],
Cell[39702, 1169, 1271, 34, 182, "Input"],
Cell[40976, 1205, 373, 10, 55, "Input"],
Cell[41352, 1217, 1168, 32, 182, "Input"],
Cell[42523, 1251, 4052, 103, 308, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[46612, 1359, 35, 0, 43, "Section"],
Cell[46650, 1361, 1688, 50, 90, "Input"],
Cell[48341, 1413, 433, 11, 55, "Input"],
Cell[48777, 1426, 1747, 46, 187, "Input"],
Cell[50527, 1474, 2029, 49, 209, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[52593, 1528, 35, 0, 43, "Section"],
Cell[52631, 1530, 815, 20, 100, "Input"],
Cell[53449, 1552, 579, 14, 99, "Input"],
Cell[54031, 1568, 549, 15, 55, "Input"],
Cell[54583, 1585, 1151, 27, 99, "Input"],
Cell[55737, 1614, 607, 18, 55, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[56381, 1637, 35, 0, 43, "Section"],
Cell[56419, 1639, 486, 14, 55, "Input"],
Cell[56908, 1655, 570, 15, 77, "Input"],
Cell[57481, 1672, 873, 23, 99, "Input"],
Cell[58357, 1697, 1650, 60, 55, "Input"],
Cell[60010, 1759, 1658, 60, 55, "Input"],
Cell[61671, 1821, 1671, 60, 55, "Input"],
Cell[63345, 1883, 966, 26, 113, "Input"],
Cell[64314, 1911, 1852, 46, 187, "Input"],
Cell[66169, 1959, 779, 23, 55, "Input"],
Cell[66951, 1984, 1285, 31, 165, "Input"],
Cell[68239, 2017, 825, 21, 121, "Input"],
Cell[69067, 2040, 1012, 25, 173, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[70116, 2070, 50, 0, 73, "Section"],
Cell[70169, 2072, 783, 21, 77, "Input"],
Cell[70955, 2095, 784, 21, 77, "Input"],
Cell[71742, 2118, 1402, 38, 143, "Input"],
Cell[73147, 2158, 1408, 38, 143, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[74592, 2201, 45, 0, 73, "Section"],
Cell[74640, 2203, 1024, 33, 91, "Input"],
Cell[75667, 2238, 863, 27, 61, "Input"],
Cell[76533, 2267, 838, 28, 61, "Input"],
Cell[77374, 2297, 504, 16, 61, "Input"],
Cell[77881, 2315, 525, 17, 61, "Input"],
Cell[78409, 2334, 535, 17, 61, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[78981, 2356, 28, 0, 73, "Section"],
Cell[79012, 2358, 555, 16, 77, "Input"],
Cell[79570, 2376, 440, 14, 77, "Input"],
Cell[80013, 2392, 652, 21, 77, "Input"],
Cell[80668, 2415, 1150, 33, 121, "Input"],
Cell[81821, 2450, 404, 12, 77, "Input"],
Cell[82228, 2464, 838, 21, 121, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[83103, 2490, 46, 0, 73, "Section"],
Cell[83152, 2492, 693, 18, 99, "Input"],
Cell[83848, 2512, 922, 26, 55, "Input"],
Cell[84773, 2540, 1032, 29, 61, "Input"],
Cell[85808, 2571, 1125, 28, 99, "Input"],
Cell[86936, 2601, 895, 27, 122, "Input"],
Cell[87834, 2630, 1447, 41, 129, "Input"],
Cell[89284, 2673, 799, 23, 120, "Input"],
Cell[90086, 2698, 926, 25, 99, "Input"]
}, Open  ]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)
